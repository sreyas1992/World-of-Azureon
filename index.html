<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World of Azureon - Fantasy Adventure</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <style>
        /* ===============================================
           GLOBAL STYLES & RESET
        =============================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', serif;
            background: #0a0f1c;
            color: #e8e3d3;
            overflow: hidden;
            height: 100vh;
        }

        /* ===============================================
           SCREEN MANAGEMENT
        =============================================== */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.8s ease-in-out, transform 0.8s ease-in-out;
            z-index: 1;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
            transform: scale(1);
        }

        /* ===============================================
           TITLE SCREEN
        =============================================== */
        .title-container {
            width: 100vw;
            height: 100vh;
            background-image: url('World of Azureon.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .title-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(26, 26, 46, 0.6));
            backdrop-filter: blur(2px);
        }

        .title-content {
            position: relative;
            z-index: 10;
            text-align: center;
            max-width: 800px;
            padding: 40px;
        }

        .game-title {
            font-family: 'Cinzel', serif;
            font-size: 4.5em;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 
                0 0 20px rgba(255, 215, 0, 0.8),
                0 0 40px rgba(255, 215, 0, 0.6),
                4px 4px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 20px;
            animation: titleGlow 3s ease-in-out infinite alternate;
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-family: 'Crimson Text', serif;
            font-size: 1.8em;
            color: #c9aa71;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 40px;
            font-style: italic;
        }

        .title-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .btn-epic {
            background: linear-gradient(135deg, #4a1580, #1e293b);
            border: 3px solid #ffd700;
            border-radius: 50px;
            padding: 18px 40px;
            font-family: 'Cinzel', serif;
            font-size: 1.2em;
            font-weight: 600;
            color: #ffd700;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 215, 0, 0.1);
            position: relative;
            overflow: hidden;
            min-width: 250px;
        }

        .btn-epic:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn-epic:hover:before {
            left: 100%;
        }

        .btn-epic:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 35px rgba(0, 0, 0, 0.6),
                inset 0 2px 8px rgba(255, 215, 0, 0.2);
            border-color: #fff;
            color: #fff;
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
        }

        .btn-epic:active {
            transform: translateY(-1px);
        }

        /* ===============================================
           PARTICLE SYSTEM
        =============================================== */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ffd700;
            border-radius: 50%;
            opacity: 0.7;
            animation: float 6s infinite linear;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.7;
            }
            90% {
                opacity: 0.7;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes titleGlow {
            0% {
                text-shadow: 
                    0 0 20px rgba(255, 215, 0, 0.8),
                    0 0 40px rgba(255, 215, 0, 0.6),
                    4px 4px 8px rgba(0, 0, 0, 0.8);
            }
            100% {
                text-shadow: 
                    0 0 30px rgba(255, 215, 0, 1),
                    0 0 60px rgba(255, 215, 0, 0.8),
                    4px 4px 12px rgba(0, 0, 0, 0.9);
            }
        }

        /* ===============================================
           CHARACTER SELECTION SCREEN
        =============================================== */
        .character-selection {
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .selection-title {
            font-family: 'Cinzel', serif;
            font-size: 3em;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            margin-bottom: 20px;
            text-align: center;
        }

        .subtitle {
            font-size: 1.3em;
            color: #c9aa71;
            margin-bottom: 40px;
            text-align: center;
            font-style: italic;
        }

        .name-input-section {
            margin-bottom: 40px;
            text-align: center;
        }

        .name-input-section label {
            display: block;
            font-family: 'Cinzel', serif;
            font-size: 1.2em;
            color: #ffd700;
            margin-bottom: 10px;
        }

        #playerName {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd700;
            border-radius: 25px;
            padding: 12px 20px;
            font-size: 1.1em;
            color: #e8e3d3;
            text-align: center;
            min-width: 250px;
            font-family: 'Crimson Text', serif;
        }

        #playerName:focus {
            outline: none;
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .characters-container {
            display: flex;
            gap: 40px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .character-card {
            background: linear-gradient(135deg, rgba(74, 21, 128, 0.8), rgba(30, 41, 59, 0.8));
            border: 3px solid rgba(255, 215, 0, 0.6);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 250px;
            position: relative;
            overflow: hidden;
        }

        .character-card:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .character-card:hover:before {
            opacity: 1;
        }

        .character-card:hover {
            transform: translateY(-10px);
            border-color: #ffd700;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
        }

        .character-card.selected {
            border-color: #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(74, 21, 128, 0.8));
            transform: scale(1.05);
        }

        .character-card.selected:after {
            content: '✓';
            position: absolute;
            top: 10px;
            right: 15px;
            color: #22c55e;
            font-size: 2em;
            font-weight: bold;
        }

        .character-image {
            width: 140px;
            height: 140px;
            margin: 0 auto 20px;
            border-radius: 15px;
            overflow: hidden;
            border: 3px solid rgba(255, 215, 0, 0.5);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .character-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
        }

        .character-card:hover .character-image {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .character-name {
            font-family: 'Cinzel', serif;
            font-size: 1.5em;
            color: #ffd700;
            margin-bottom: 8px;
        }

        .character-subtitle {
            color: #c9aa71;
            font-size: 1em;
            margin-bottom: 15px;
            font-style: italic;
        }

        .character-desc {
            color: #e8e3d3;
            font-size: 0.95em;
            line-height: 1.4;
        }

        /* ===============================================
           KINGDOM SELECTION SCREEN
        =============================================== */
        .kingdom-selection {
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 40px;
            overflow-y: auto;
        }

        .kingdoms-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            max-width: 1200px;
            margin-bottom: 40px;
        }

        .kingdom-card {
            background: linear-gradient(135deg, rgba(74, 21, 128, 0.8), rgba(30, 41, 59, 0.8));
            border: 3px solid rgba(255, 215, 0, 0.6);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .kingdom-card:hover {
            transform: translateY(-8px);
            border-color: #ffd700;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.6);
        }

        .kingdom-card.selected {
            border-color: #22c55e;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(74, 21, 128, 0.8));
            transform: scale(1.02);
        }

        .kingdom-icon {
            font-size: 3em;
            margin-bottom: 15px;
            display: block;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.6));
        }

        .kingdom-name {
            font-family: 'Cinzel', serif;
            font-size: 1.4em;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .kingdom-desc {
            color: #e8e3d3;
            font-size: 0.95em;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .kingdom-trait {
            color: #c9aa71;
            font-size: 0.85em;
            font-style: italic;
        }

        /* ===============================================
           LEVEL 1 INTRO SCREEN
        =============================================== */
        .level-intro-container {
            width: 100vw;
            height: 100vh;
            background-image: url('Whispers of forest.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .level-intro-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(2px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .level-intro-content {
            max-width: 800px;
            padding: 40px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            border: 3px solid #ffd700;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .level-title {
            font-family: 'Cinzel', serif;
            font-size: 3.5em;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            margin-bottom: 10px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        .level-subtitle {
            font-family: 'Cinzel', serif;
            font-size: 2em;
            color: #22c55e;
            text-shadow: 0 0 15px rgba(34, 197, 94, 0.6);
            margin-bottom: 30px;
        }

        .level-description {
            text-align: left;
            margin-bottom: 30px;
        }

        .level-story {
            font-family: 'Crimson Text', serif;
            font-size: 1.2em;
            color: #e8e3d3;
            line-height: 1.6;
            margin-bottom: 25px;
            text-align: center;
            font-style: italic;
        }

        .level-objectives {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .level-objectives h3 {
            font-family: 'Cinzel', serif;
            color: #ffd700;
            margin-bottom: 15px;
            text-align: center;
        }

        .level-objectives ul {
            list-style: none;
            padding: 0;
        }

        .level-objectives li {
            color: #e8e3d3;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }

        .level-objectives li:last-child {
            border-bottom: none;
        }

        .level-start-btn {
            font-size: 1.3em !important;
            padding: 15px 40px !important;
            animation: buttonGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titlePulse {
            0%, 100% { 
                text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
                transform: scale(1);
            }
            50% { 
                text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.6);
                transform: scale(1.05);
            }
        }

        @keyframes buttonGlow {
            0% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            }
            100% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), 0 0 35px rgba(255, 215, 0, 0.4);
            }
        }

        /* ===============================================
           LEVEL 1 GAME SCREEN
        =============================================== */
        .game-container {
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 30%, #228B22 100%);
            position: relative;
            overflow: hidden;
        }

        .game-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.7));
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(255, 215, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
        }

        .hud-left, .hud-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .hud-center {
            text-align: center;
        }

        .level-title-hud {
            font-family: 'Cinzel', serif;
            font-size: 1.2em;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            font-weight: 600;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255, 215, 0, 0.4);
        }

        .hud-icon {
            font-size: 1.2em;
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.6));
        }

        .player-info, .kingdom-info {
            color: #e8e3d3;
            font-family: 'Crimson Text', serif;
            font-weight: 600;
        }

        .life-counter {
            display: flex;
            gap: 5px;
        }

        .life-heart {
            font-size: 1.1em;
            transition: all 0.3s ease;
        }

        .life-heart.lost {
            opacity: 0.3;
            filter: grayscale(100%);
        }

        .forest-relic-indicator {
            font-size: 1.2em;
            margin-left: 10px;
            animation: forest-relic-glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes forest-relic-glow {
            0% { text-shadow: 0 0 5px #00FF7F, 0 0 10px #00FF7F; }
            100% { text-shadow: 0 0 10px #00FF7F, 0 0 20px #00FF7F, 0 0 30px #00FF7F; }
        }

        /* Score System */
        .score-system {
            position: absolute;
            top: 100px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 90;
            pointer-events: none;
        }

        .player-score-panel, .kingdom-score-panel {
            background: linear-gradient(135deg, rgba(74, 21, 128, 0.9), rgba(30, 41, 59, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 15px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 180px;
            transition: all 0.3s ease;
        }

        .score-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .score-icon {
            font-size: 18px;
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.6));
        }

        .score-title {
            font-family: 'Cinzel', serif;
            font-size: 14px;
            font-weight: 600;
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        .score-value {
            font-family: 'Cinzel', serif;
            font-size: 28px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            margin-bottom: 4px;
            animation: scoreGlow 2s ease-in-out infinite alternate;
        }

        .score-subtitle {
            font-family: 'Crimson Text', serif;
            font-size: 12px;
            color: #c9aa71;
            text-shadow: 0 0 4px rgba(201, 170, 113, 0.3);
            font-style: italic;
        }

        @keyframes scoreGlow {
            0% {
                text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            }
            100% {
                text-shadow: 0 0 15px rgba(255, 215, 0, 1), 0 0 25px rgba(255, 215, 0, 0.6);
            }
        }

        /* Game Canvas */
        #gameCanvas {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            border: 3px solid rgba(255, 215, 0, 0.6);
            border-radius: 10px;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 50%, #228B22 100%);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        /* Game Controls */
        .game-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 25px;
            color: #e8e3d3;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            font-family: 'Crimson Text', serif;
        }

        /* ===============================================
           INSTRUCTIONS MODAL
        =============================================== */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 40px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #ffd700;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            color: #fff;
            transform: scale(1.2);
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }

        .instruction-section {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
        }

        .instruction-section h3 {
            font-family: 'Cinzel', serif;
            color: #ffd700;
            margin-bottom: 15px;
        }

        .instruction-section ul {
            list-style: none;
            padding: 0;
        }

        .instruction-section li {
            color: #e8e3d3;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }

        .instruction-section li:last-child {
            border-bottom: none;
        }

        /* ===============================================
           LOADING OVERLAY
        =============================================== */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .loading-text {
            font-family: 'Cinzel', serif;
            font-size: 2em;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            margin-bottom: 30px;
            animation: pulse 2s ease-in-out infinite;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 215, 0, 0.3);
            border-top: 4px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ===============================================
           RESPONSIVE DESIGN
        =============================================== */
        @media (max-width: 600px) {
            .game-title {
                font-size: 3em;
            }
            
            .selection-title {
                font-size: 2.2em;
            }
            
            .characters-container {
                flex-direction: column;
                align-items: center;
            }
            
            .character-card {
                min-width: 280px;
            }
            
            .kingdoms-grid {
                grid-template-columns: 1fr;
                max-width: 400px;
            }
            
            .level-title {
                font-size: 2.5em;
            }
            
            .level-subtitle {
                font-size: 1.5em;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 2.5em;
            }
            
            .title-content {
                padding: 20px;
            }
            
            .character-selection,
            .kingdom-selection {
                padding: 20px;
            }
            
            .btn-epic {
                min-width: 200px;
                font-size: 1em;
                padding: 15px 30px;
            }
        }
    </style>
</head>
<body>
    <!-- Particle System -->
    <div class="particles" id="particles"></div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-text" id="loadingText">Loading...</div>
        <div class="loading-spinner"></div>
    </div>

    <!-- ===============================================
         TITLE SCREEN
    =============================================== -->
    <div id="titleScreen" class="screen active">
        <div class="title-container">
            <div class="title-overlay"></div>
            <div class="title-content">
                <h1 class="game-title">World of Azureon</h1>
                <p class="game-subtitle">An Epic Fantasy Adventure Awaits</p>
                <div class="title-buttons">
                    <button class="btn-epic" onclick="startQuest()">⚔️ Start Quest</button>
                    <button class="btn-epic" onclick="showInstructions()">📜 Instructions</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ===============================================
         CHARACTER SELECTION SCREEN
    =============================================== -->
    <div id="characterScreen" class="screen hidden">
        <div class="character-selection">
            <h2 class="selection-title">Choose Your Hero</h2>
            <p class="subtitle">Enter your name and select your champion</p>
            
            <div class="name-input-section">
                <label for="playerName">Enter Your Name, Brave Warrior:</label>
                <input type="text" id="playerName" placeholder="Your Hero Name" maxlength="20" />
            </div>
            
            <div class="characters-container">
                <div class="character-card" data-character="kael" onclick="selectCharacter('kael')">
                    <div class="character-image">
                        <img src="Boy Warrior.png" alt="Kael - Boy Warrior" />
                    </div>
                    <h3 class="character-name">Kael</h3>
                    <p class="character-subtitle">The Boy Warrior</p>
                    <p class="character-desc">Master of the blade with unmatched courage. Born of noble blood, seeks glory and honor in every battle.</p>
                </div>
                
                <div class="character-card" data-character="lyra" onclick="selectCharacter('lyra')">
                    <div class="character-image">
                        <img src="Girl Warrior.png" alt="Lyra - Girl Warrior" />
                    </div>
                    <h3 class="character-name">Lyra</h3>
                    <p class="character-subtitle">The Girl Warrior</p>
                    <p class="character-desc">Legendary archer with perfect aim. Blessed with ancient magic and unmatched agility.</p>
                </div>
            </div>
            
            <button class="btn-epic" id="confirmCharacter" onclick="proceedToKingdoms()" style="display:none;">Continue to Kingdoms →</button>
        </div>
    </div>

    <!-- ===============================================
         KINGDOM SELECTION SCREEN
    =============================================== -->
    <div id="kingdomScreen" class="screen hidden">
        <div class="kingdom-selection">
            <h2 class="selection-title">Choose Your Kingdom</h2>
            <p class="subtitle">Each realm offers unique powers and challenges</p>
            
            <div class="kingdoms-grid">
                <div class="kingdom-card" data-kingdom="emberis" onclick="selectKingdom('emberis')">
                    <span class="kingdom-icon">🔥</span>
                    <h3 class="kingdom-name">Emberis (CMOF)</h3>
                    <p class="kingdom-desc">The Flame Kingdom - Where fire magic burns eternal and warriors forge their destiny in molten steel.</p>
                    <p class="kingdom-trait">Fiery & Bold</p>
                </div>
                
                <div class="kingdom-card" data-kingdom="aqualis" onclick="selectKingdom('aqualis')">
                    <span class="kingdom-icon">🌊</span>
                    <h3 class="kingdom-name">Aqualis (MCP)</h3>
                    <p class="kingdom-desc">The Water Kingdom - Mystical realm where ancient tides hold secrets of forgotten magic.</p>
                    <p class="kingdom-trait">Water-based & Mystical</p>
                </div>
                
                <div class="kingdom-card" data-kingdom="greenveil" onclick="selectKingdom('greenveil')">
                    <span class="kingdom-icon">🌿</span>
                    <h3 class="kingdom-name">Greenveil (CS4)</h3>
                    <p class="kingdom-desc">The Nature Kingdom - Lush forests where life magic flows through every leaf and branch.</p>
                    <p class="kingdom-trait">Lush & Nature-bound</p>
                </div>
                
                <div class="kingdom-card" data-kingdom="luminaris" onclick="selectKingdom('luminaris')">
                    <span class="kingdom-icon">✨</span>
                    <h3 class="kingdom-name">Luminaris (S&T)</h3>
                    <p class="kingdom-desc">The Light Kingdom - Radiant realm where wisdom illuminates the path to enlightenment.</p>
                    <p class="kingdom-trait">Radiant & Wise</p>
                </div>
                
                <div class="kingdom-card" data-kingdom="shadowmere" onclick="selectKingdom('shadowmere')">
                    <span class="kingdom-icon">🌙</span>
                    <h3 class="kingdom-name">Shadowmere (CSCP-E)</h3>
                    <p class="kingdom-desc">The Shadow Kingdom - Mysterious realm where darkness conceals ancient secrets and power.</p>
                    <p class="kingdom-trait">Mysterious & Dark</p>
                </div>
                
                <div class="kingdom-card" data-kingdom="crystalpeak" onclick="selectKingdom('crystalpeak')">
                    <span class="kingdom-icon">💎</span>
                    <h3 class="kingdom-name">Ironspire (SCE)</h3>
                    <p class="kingdom-desc">The Crystal Kingdom - Majestic mountains where gemstones hold the power of the earth.</p>
                    <p class="kingdom-trait">Earthbound & Strong</p>
                </div>
                
                <div class="kingdom-card" data-kingdom="frosthold" onclick="selectKingdom('frosthold')">
                    <span class="kingdom-icon">❄️</span>
                    <h3 class="kingdom-name">Frosthold (IDC)</h3>
                    <p class="kingdom-desc">The Ice Kingdom - Eternal winter realm where frozen magic preserves ancient wisdom in crystalline halls.</p>
                    <p class="kingdom-trait">Frozen & Eternal</p>
                </div>
            </div>
        </div>
    </div>

    <!-- ===============================================
         LEVEL 1 INTRO SCREEN
    =============================================== -->
    <div id="level1IntroScreen" class="screen hidden">
        <div class="level-intro-container">
            <div class="level-intro-overlay">
                <div class="level-intro-content">
                    <h1 class="level-title">Level 1</h1>
                    <h2 class="level-subtitle">Whispers of the Forest</h2>
                    <div class="level-description">
                        <p class="level-story">Deep within the ancient forest, mysterious whispers guide your path. 
                        Navigate through dangerous terrain, collect magical tokens, and discover the secrets that lie hidden in the shadows of towering trees.</p>
                        
                        <div class="level-objectives">
                            <h3>🎯 Your Quest</h3>
                            <ul>
                                <li>🏃‍♂️ Navigate through the mystical forest paths</li>
                                <li>💰 Collect magical tokens and treasures</li>
                                <li>⚡ Avoid deadly spikes and treacherous obstacles</li>
                                <li>🎭 Face the challenges that test your courage</li>
                                <li>🏆 Reach the forest exit to claim victory</li>
                            </ul>
                        </div>
                    </div>
                    
                    <button class="btn-epic level-start-btn" onclick="startLevel1()">🌲 Enter the Forest 🌲</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ===============================================
         LEVEL 1 GAME SCREEN
    =============================================== -->
    <div id="gameScreen" class="screen hidden">
        <div class="game-container">
            <!-- Game HUD -->
            <div class="game-hud">
                <div class="hud-left">
                    <div class="hud-item player-info">
                        <span class="hud-icon">👤</span>
                        <span id="playerDisplay">Player</span>
                    </div>
                    <div class="hud-item kingdom-info">
                        <span class="hud-icon">🏰</span>
                        <span id="kingdomDisplay">Kingdom</span>
                    </div>
                </div>
                
                <div class="hud-center">
                    <div class="level-title-hud">Level 1: Whispers of the Forest</div>
                </div>
                
                <div class="hud-right">
                    <div class="hud-item lives-display">
                        <span class="hud-icon">❤️</span>
                        <div class="life-counter">
                            <div class="life-heart" id="life1">❤️</div>
                            <div class="life-heart" id="life2">❤️</div>
                            <div class="life-heart" id="life3">❤️</div>
                        </div>
                        <div class="forest-relic-indicator" id="forestRelicIndicator" style="display: none;">
                            🌟
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Score Panels -->
            <div class="score-system">
                <!-- Player Score (Top-Left) -->
                <div class="player-score-panel">
                    <div class="score-header">
                        <span class="score-icon">⚔️</span>
                        <span class="score-title">Your Score</span>
                    </div>
                    <div class="score-value" id="playerScoreValue">0</div>
                    <div class="score-subtitle" id="playerNameDisplay">Warrior</div>
                </div>
                
                <!-- Kingdom Score (Top-Right) -->
                <div class="kingdom-score-panel">
                    <div class="score-header">
                        <span class="score-icon" id="kingdomIconDisplay">🏰</span>
                        <span class="score-title" id="kingdomNameDisplay">Kingdom</span>
                    </div>
                    <div class="score-value" id="kingdomScoreValue">0</div>
                    <div class="score-subtitle">Kingdom Glory</div>
                </div>
            </div>

            <!-- Game Canvas -->
            <canvas id="gameCanvas" width="1200" height="600"></canvas>

            <!-- Game Controls Info -->
            <div class="game-controls">
                ← → Arrow Keys to Move | ↑ Spacebar to Jump | ↑↓ Climb Green Ropes | ESC to Pause
            </div>
        </div>
    </div>

    <!-- ===============================================
         INSTRUCTIONS MODAL
    =============================================== -->
    <div id="instructionsModal" class="modal hidden">
        <div class="modal-content">
            <button class="close-modal" onclick="hideInstructions()">&times;</button>
            <h2 style="font-family: 'Cinzel', serif; color: #ffd700; text-align: center; margin-bottom: 30px;">⚔️ World of Azureon Guide ⚔️</h2>
            
            <div class="instructions-grid">
                <div class="instruction-section">
                    <h3>🎮 Game Controls</h3>
                    <ul>
                        <li>Move Left/Right: ← → Arrow Keys</li>
                        <li>Jump: ↑ Arrow Key or Spacebar</li>
                        <li>Pause Game: ESC Key</li>
                        <li>Return to Menu: R Key</li>
                    </ul>
                </div>
                
                <div class="instruction-section">
                    <h3>🎯 Your Quest</h3>
                    <ul>
                        <li>Navigate through mystical forest levels</li>
                        <li>Collect magical orbs and treasures</li>
                        <li>Avoid dangerous obstacles and enemies</li>
                        <li>Reach the end of each level safely</li>
                    </ul>
                </div>
                
                <div class="instruction-section">
                    <h3>💎 Character Powers</h3>
                    <ul>
                        <li>Kael: Enhanced combat abilities</li>
                        <li>Lyra: Superior jumping and agility</li>
                        <li>Kingdom bonuses unlock special skills</li>
                        <li>Level up to gain new powers</li>
                    </ul>
                </div>
                
                <div class="instruction-section">
                    <h3>🏰 Kingdom Benefits</h3>
                    <ul>
                        <li>Each kingdom grants unique abilities</li>
                        <li>Discover kingdom-specific magic spells</li>
                        <li>Unlock exclusive weapons and armor</li>
                        <li>Access to special kingdom levels</li>
                    </ul>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn-epic" onclick="hideInstructions()">Begin Your Adventure!</button>
            </div>
        </div>
    </div>

    <!-- ===============================================
         JAVASCRIPT GAME LOGIC
    =============================================== -->
    <script>
        // ===============================================
        // GAME STATE MANAGEMENT
        // ===============================================
        let gameState = {
            currentScreen: 'title',
            playerName: '',
            selectedCharacter: '',
            selectedKingdom: '',
            lives: 3,
            health: 100,
            score: 0,
            level: 1,
            hasForestRelic: false
        };



        // Global game variables
        let enemies = {}; // Page-based enemy arrays
        let platforms = {}; // Page-based platform arrays
        let collectibles = {}; // Page-based collectible arrays
        let currentPage = 0; // Current page number
        let player = null; // Player object
        let canvasWidth = 800;
        let canvasHeight = 600;
        let cameraX = 0;
        let cameraY = 0;

        // ===============================================
        // INITIALIZATION
        // ===============================================
        function initializeGame() {
            initializeParticles();
            console.log('World of Azureon initialized successfully!');
        }

        function initializeParticles() {
            const particlesContainer = document.getElementById('particles');
            const particleCount = 30;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (4 + Math.random() * 4) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        // ===============================================
        // SCREEN TRANSITIONS
        // ===============================================
        function showScreen(screenId) {
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
                screen.classList.add('hidden');
            });
            
            // Show target screen
            const targetScreen = document.getElementById(screenId + 'Screen');
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
                targetScreen.classList.add('active');
                gameState.currentScreen = screenId;
            }
        }

        function transitionToScreen(screenId, loadingText = 'Loading...') {
            showLoading(loadingText);
            
            setTimeout(() => {
                showScreen(screenId);
                hideLoading();
            }, 1500);
        }

        function showLoading(text = 'Loading...') {
            const overlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = text;
            overlay.classList.add('active');
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('active');
        }

        // ===============================================
        // TITLE SCREEN FUNCTIONS
        // ===============================================
        function startQuest() {
            transitionToScreen('character', 'Loading Character Selection...');
            setTimeout(() => {
                const nameInput = document.getElementById('playerName');
                if (nameInput) nameInput.focus();
            }, 1600);
        }

        function showInstructions() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }

        function hideInstructions() {
            document.getElementById('instructionsModal').classList.add('hidden');
        }

        // ===============================================
        // CHARACTER SELECTION
        // ===============================================
        function selectCharacter(character) {
            const nameInput = document.getElementById('playerName');
            const playerName = nameInput.value.trim();
            
            if (!playerName) {
                alert('Please enter your name first, brave warrior!');
                nameInput.focus();
                return;
            }
            
            if (playerName.length < 2) {
                alert('Your name must be at least 2 characters long!');
                nameInput.focus();
                return;
            }
            
            gameState.playerName = playerName;
            gameState.selectedCharacter = character;
            
            // Visual feedback
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            document.querySelector(`[data-character="${character}"]`).classList.add('selected');
            document.getElementById('confirmCharacter').style.display = 'block';
            
            console.log(`Character selected: ${character} (${playerName})`);
        }

        function proceedToKingdoms() {
            if (!gameState.selectedCharacter) {
                alert('Please select a character first!');
                return;
            }
            transitionToScreen('kingdom', 'Entering the Kingdom Selection...');
        }

        // ===============================================
        // KINGDOM SELECTION
        // ===============================================
        function selectKingdom(kingdom) {
            gameState.selectedKingdom = kingdom;
            
            // Get the full kingdom name with abbreviation from the selected card
            const selectedCard = document.querySelector(`[data-kingdom="${kingdom}"]`);
            const kingdomNameElement = selectedCard.querySelector('.kingdom-name');
            const fullKingdomName = kingdomNameElement ? kingdomNameElement.textContent : kingdom;
            
            // Store kingdom name in localStorage for later levels
            localStorage.setItem('azureon_kingdom_name', fullKingdomName);
            
            // Visual feedback
            document.querySelectorAll('.kingdom-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            selectedCard.classList.add('selected');
            
            // Auto-advance to Level 1 after selection
            setTimeout(() => {
                transitionToScreen('level1Intro', `Preparing for Level 1: Whispers of the Forest...`);
            }, 1500);
            
            console.log(`Kingdom selected: ${kingdom} (${fullKingdomName})`);
        }

        // ===============================================
        // LEVEL 1 FUNCTIONS
        // ===============================================
        function startLevel1() {
            // Initialize player stats
            gameState.lives = 3;
            gameState.health = 100;
            gameState.score = 0;
            
            showLoading('Entering the Whispers of the Forest...');
            
            setTimeout(() => {
                transitionToScreen('game', 'Loading Forest Adventure...');
                setTimeout(() => {
                    initializeForestGame();
                }, 1000);
            }, 1500);
        }



        // ===============================================
        // UTILITY FUNCTIONS
        // ===============================================
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // ===============================================
        // EVENT LISTENERS & INITIALIZATION
        // ===============================================
        document.addEventListener('DOMContentLoaded', function() {
            initializeGame();
            
            // Add enter key support for name input
            const nameInput = document.getElementById('playerName');
            if (nameInput) {
                nameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        const characterCards = document.querySelectorAll('.character-card');
                        if (characterCards.length > 0) {
                            characterCards[0].click();
                        }
                    }
                });
            }
            
            // Add escape key to close modals
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('instructionsModal');
                    if (modal && !modal.classList.contains('hidden')) {
                        hideInstructions();
                    }
                }
            });
        });

        // ===============================================
        // LEVEL 1 FOREST GAME ENGINE
        // ===============================================
        let forestGame = {
            canvas: null,
            ctx: null,
            running: false,
            animationId: null,
            
            // Player properties with animation system
            player: {
                x: 100,
                y: 400,
                width: 40,
                height: 50,
                velocityX: 0,
                velocityY: 0,
                speed: 6,
                jumpPower: 15,
                onGround: false,
                direction: 1,
                
                // Animation properties
                state: 'idle', // idle, running, jumping, falling
                animFrame: 0,
                animTimer: 0,
                animSpeed: 8,
                
                // Warrior appearance
                baseColor: gameState.selectedCharacter === 'kael' ? '#4169E1' : '#DC143C',
                armorColor: '#C0C0C0',
                weaponColor: '#FFD700',
                
                // Combat properties
                invulnerable: false,
                invulnerabilityTimer: 0,
                
                // Sword combat properties
                attacking: false,
                attackTimer: 0,
                attackCooldown: 0,
                swordReach: 100
            },
            
            // Camera
            camera: {
                x: 0,
                y: 0,
                shakeTimer: 0,
                shakeIntensity: 0
            },
            
            // Game elements
            platforms: [],
            obstacles: [],
            collectibles: [],
            clouds: [],
            trees: [],
            crumblingTiles: [],
            movingPlatforms: [],
            marshes: [],
            particles: [],
            
            // Game state
            currentPage: 1,
            pageWidth: 1600,
            totalPages: 3,
            swordFound: false,
            page3Created: false,
            
            // Controls
            keys: {},
            
            // Score popup system
            scorePopups: []
        };

        function initializeForestGame() {
            // Get canvas and context
            forestGame.canvas = document.getElementById('gameCanvas');
            forestGame.ctx = forestGame.canvas.getContext('2d');
            
            if (!forestGame.ctx) {
                alert('Your browser does not support the game canvas.');
                return;
            }
            
            // Update HUD
            updateGameHUD();
            
            // Initialize game elements
            createForestLevel();
            
            // Setup controls
            setupGameControls();
            
            // Start game loop
            forestGame.running = true;
            forestGameLoop();
            
            console.log('Forest game initialized successfully!');
        }

        function updateScore(points) {
            if (points) {
                gameState.score += points;
                console.log(`Score updated: +${points} points. Total: ${gameState.score}`);
            }
            updateGameHUD();
        }
        
        function updateGameHUD() {
            document.getElementById('playerDisplay').textContent = gameState.playerName;
            document.getElementById('kingdomDisplay').textContent = capitalizeFirst(gameState.selectedKingdom);
            document.getElementById('playerScoreValue').textContent = gameState.score.toLocaleString();
            document.getElementById('kingdomScoreValue').textContent = Math.floor(gameState.score * 1.5).toLocaleString();
            document.getElementById('playerNameDisplay').textContent = gameState.playerName;
            document.getElementById('kingdomNameDisplay').textContent = capitalizeFirst(gameState.selectedKingdom);
            
            // Set kingdom icon
            const kingdomIcons = {
                emberis: '🔥', aqualis: '🌊', greenveil: '🌿',
                luminaris: '✨', shadowmere: '🌙', crystalpeak: '💎'
            };
            document.getElementById('kingdomIconDisplay').textContent = kingdomIcons[gameState.selectedKingdom] || '🏰';
        }

        function createForestLevel() {
            // Create platforms
            forestGame.platforms = [
                // Ground platforms
                { x: 0, y: 550, width: 300, height: 50, type: 'ground' },
                { x: 400, y: 550, width: 250, height: 50, type: 'ground' },
                { x: 750, y: 550, width: 300, height: 50, type: 'ground' },
                { x: 1150, y: 550, width: 450, height: 50, type: 'ground' }, // Extended to 1600
                
                // Floating platforms
                { x: 350, y: 450, width: 120, height: 20, type: 'tree_branch' },
                { x: 600, y: 380, width: 100, height: 20, type: 'tree_branch' },
                { x: 850, y: 420, width: 120, height: 20, type: 'tree_branch' },
                { x: 1050, y: 350, width: 100, height: 20, type: 'tree_branch' },
                { x: 1300, y: 400, width: 120, height: 20, type: 'tree_branch' },
                
                // Bridge platforms for page transition
                { x: 1450, y: 480, width: 150, height: 20, type: 'bridge' },
                { x: 1550, y: 450, width: 100, height: 20, type: 'bridge' }
            ];
            
            // Create enhanced obstacles with animations
            forestGame.obstacles = [
                { x: 320, y: 530, width: 30, height: 20, type: 'iron_spike', animFrame: 0 },
                { x: 680, y: 530, width: 30, height: 20, type: 'poison_spike', animFrame: 0 },
                { x: 1080, y: 530, width: 30, height: 20, type: 'fire_spike', animFrame: 0 },
                { x: 500, y: 360, width: 40, height: 20, type: 'thorn_bush', animFrame: 0 },
                { x: 900, y: 400, width: 40, height: 20, type: 'crystal_spikes', animFrame: 0 }
            ];
            
            // Add crumbling tiles
            forestGame.crumblingTiles = [
                { x: 550, y: 480, width: 80, height: 20, integrity: 100, maxIntegrity: 100, crumbling: false, stepCount: 0 },
                { x: 780, y: 450, width: 60, height: 20, integrity: 100, maxIntegrity: 100, crumbling: false, stepCount: 0 },
                { x: 1180, y: 420, width: 70, height: 20, integrity: 100, maxIntegrity: 100, crumbling: false, stepCount: 0 }
            ];
            
            // Create collectibles with variety of tokens and powerups
            forestGame.collectibles = [
                { x: 380, y: 420, width: 30, height: 30, collected: false, type: 'gold_coin', value: 75, color: '#FFD700' },
                { x: 630, y: 350, width: 30, height: 30, collected: false, type: 'silver_coin', value: 50, color: '#C0C0C0' },
                { x: 880, y: 390, width: 30, height: 30, collected: false, type: 'emerald', value: 150, color: '#50C878' },
                { x: 1080, y: 320, width: 30, height: 30, collected: false, type: 'ruby', value: 200, color: '#E0115F' },
                { x: 1330, y: 370, width: 40, height: 30, collected: false, type: 'treasure_chest', value: 300, color: '#B8860B' },
                { x: 200, y: 520, width: 25, height: 35, collected: false, type: 'health_potion', value: 0, color: '#FF1493', effect: 'heal' },
                { x: 800, y: 520, width: 25, height: 35, collected: false, type: 'speed_boost', value: 100, color: '#00BFFF', effect: 'speed' },
                { x: 500, y: 520, width: 30, height: 30, collected: false, type: 'gold_coin', value: 75, color: '#FFD700' },
                { x: 1200, y: 320, width: 25, height: 35, collected: false, type: 'health_potion', value: 0, color: '#FF1493', effect: 'heal' }
            ];
            
            // Create moving clouds (across both pages)
            forestGame.clouds = [
                { x: 100, y: 50, width: 80, height: 40, speed: 0.5 },
                { x: 300, y: 30, width: 100, height: 50, speed: 0.3 },
                { x: 600, y: 70, width: 90, height: 45, speed: 0.4 },
                { x: 900, y: 40, width: 110, height: 55, speed: 0.2 },
                { x: 1200, y: 60, width: 85, height: 40, speed: 0.6 },
                { x: 1500, y: 45, width: 95, height: 50, speed: 0.35 },
                { x: 1800, y: 35, width: 75, height: 35, speed: 0.55 },
                { x: 2100, y: 65, width: 105, height: 45, speed: 0.25 }
            ];
            
            // Create background trees
            forestGame.trees = [
                { x: 50, y: 300, height: 250, type: 'tall' },
                { x: 250, y: 350, height: 200, type: 'medium' },
                { x: 450, y: 280, height: 270, type: 'tall' },
                { x: 700, y: 320, height: 230, type: 'medium' },
                { x: 950, y: 250, height: 300, type: 'tall' },
                { x: 1200, y: 340, height: 210, type: 'medium' },
                { x: 1400, y: 270, height: 280, type: 'tall' }
            ];
            
            // Initialize moving platforms (Page 1 - Forest)
            forestGame.movingPlatforms = [
                { x: 480, y: 380, width: 100, height: 20, vx: 1, minX: 450, maxX: 600, page: 1 },
                { x: 950, y: 320, width: 80, height: 15, vx: -0.8, minX: 900, maxX: 1100, page: 1 }
            ];
            
            // Initialize marshes (Page 2 - Marshlands)
            forestGame.marshes = [
                { x: 1600, y: 500, width: 150, height: 50, damage: 5, page: 2 },
                { x: 1900, y: 480, width: 120, height: 60, damage: 5, page: 2 },
                { x: 2200, y: 520, width: 180, height: 30, damage: 5, page: 2 }
            ];
            
            // Initialize particle system
            forestGame.particles = [];
            
            // Set up page system
            forestGame.currentPage = 1;
            forestGame.pageWidth = 1600;
            forestGame.totalPages = 3;
            forestGame.swordFound = false;
            forestGame.page2Created = false;
            forestGame.page3Created = false;
            
            // Initialize enemies array
            forestGame.enemies = [];
        }
        
        function createMarshlandsElements() {
            const pageOffset = forestGame.pageWidth; // Page 2 starts at x = 1200
            
            // Add Page 2 platforms (marshlands style)
            const page2Platforms = [
                // Ground platforms with gaps for marshes
                { x: pageOffset + 0, y: 550, width: 200, height: 50, type: 'stone' },
                { x: pageOffset + 350, y: 550, width: 180, height: 50, type: 'stone' },
                { x: pageOffset + 680, y: 550, width: 220, height: 50, type: 'stone' },
                { x: pageOffset + 1000, y: 550, width: 300, height: 50, type: 'stone' }, // Extended
                { x: pageOffset + 1400, y: 550, width: 200, height: 50, type: 'stone' }, // New platform
                
                // Floating stone platforms
                { x: pageOffset + 250, y: 450, width: 80, height: 20, type: 'floating_stone' },
                { x: pageOffset + 450, y: 400, width: 100, height: 20, type: 'floating_stone' },
                { x: pageOffset + 650, y: 380, width: 90, height: 20, type: 'floating_stone' },
                { x: pageOffset + 850, y: 420, width: 120, height: 20, type: 'floating_stone' },
                { x: pageOffset + 1100, y: 400, width: 100, height: 20, type: 'floating_stone' },
                { x: pageOffset + 1350, y: 450, width: 120, height: 20, type: 'floating_stone' },
                
                // Bridge to page 3 (only accessible with sword)
                { x: pageOffset + 1500, y: 480, width: 100, height: 20, type: 'bridge' }
            ];
            
            // Add Page 2 collectibles
            const page2Collectibles = [
                { x: pageOffset + 280, y: 420, width: 30, height: 30, collected: false, type: 'emerald', value: 150, color: '#50C878' },
                { x: pageOffset + 480, y: 370, width: 30, height: 30, collected: false, type: 'ruby', value: 200, color: '#E0115F' },
                { x: pageOffset + 680, y: 350, width: 40, height: 30, collected: false, type: 'treasure_chest', value: 500, color: '#B8860B' },
                { x: pageOffset + 880, y: 390, width: 30, height: 30, collected: false, type: 'gold_coin', value: 100, color: '#FFD700' },
                { x: pageOffset + 1100, y: 520, width: 25, height: 35, collected: false, type: 'health_potion', value: 0, color: '#FF1493', effect: 'heal' }
            ];
            
            // Add Page 2 obstacles
            const page2Obstacles = [
                { x: pageOffset + 180, y: 530, width: 40, height: 20, type: 'poison_marsh', animFrame: 0 },
                { x: pageOffset + 420, y: 530, width: 40, height: 20, type: 'crystal_spikes', animFrame: 0 },
                { x: pageOffset + 620, y: 530, width: 40, height: 20, type: 'thorn_bush', animFrame: 0 },
                { x: pageOffset + 820, y: 530, width: 40, height: 20, type: 'poison_marsh', animFrame: 0 },
                { x: pageOffset + 950, y: 530, width: 30, height: 20, type: 'crystal_spikes', animFrame: 0 }
            ];
            
            // Add challenging green ropes for platforming
            const greenRopes = [
                { x: pageOffset + 300, y: 200, width: 8, height: 180, type: 'rope' },
                { x: pageOffset + 500, y: 150, width: 8, height: 230, type: 'rope' },
                { x: pageOffset + 700, y: 180, width: 8, height: 200, type: 'rope' },
                { x: pageOffset + 900, y: 120, width: 8, height: 260, type: 'rope' },
                { x: pageOffset + 1050, y: 160, width: 8, height: 220, type: 'rope' }
            ];
            
            // Add the legendary Sword of Azureon
            const swordOfAzureon = {
                x: pageOffset + 900, y: 80, width: 40, height: 40,
                collected: false, type: 'sword_of_azureon', value: 1000,
                color: '#FFD700', effect: 'legendary_weapon'
            };
            
            // Add Page 2 background trees (dead/marsh trees)
            const page2Trees = [
                { x: pageOffset + 100, y: 320, height: 180, type: 'dead' },
                { x: pageOffset + 400, y: 300, height: 200, type: 'marsh' },
                { x: pageOffset + 700, y: 290, height: 220, type: 'dead' },
                { x: pageOffset + 1000, y: 310, height: 190, type: 'marsh' }
            ];
            
            // Append to existing arrays
            forestGame.platforms = forestGame.platforms.concat(page2Platforms).concat(greenRopes);
            forestGame.collectibles = forestGame.collectibles.concat(page2Collectibles).concat([swordOfAzureon]);
            forestGame.obstacles = forestGame.obstacles.concat(page2Obstacles);
            forestGame.trees = forestGame.trees.concat(page2Trees);
        }

        function createCombatArenaElements() {
            console.log('Creating Combat Arena (Page 3)...');
            const pageOffset = forestGame.pageWidth * 2; // Page 3 starts at x = 3200
            
            // Combat Arena platforms
            const page3Platforms = [
                // Main ground platform
                { x: pageOffset, y: 550, width: 1600, height: 50, type: 'arena_ground' },
                
                // Battle platforms for combat
                { x: pageOffset + 200, y: 450, width: 150, height: 20, type: 'battle_platform' },
                { x: pageOffset + 500, y: 400, width: 200, height: 20, type: 'battle_platform' },
                { x: pageOffset + 800, y: 420, width: 150, height: 20, type: 'battle_platform' },
                { x: pageOffset + 1200, y: 380, width: 180, height: 20, type: 'battle_platform' }
            ];
            
            // Combat Arena collectibles (removed auto-2000-point relic that was causing issues)
            const page3Collectibles = [
                // Health potions for the battle
                { x: pageOffset + 250, y: 420, width: 25, height: 35, collected: false, 
                  type: 'health_potion', value: 0, color: '#FF1493', effect: 'heal' },
                { x: pageOffset + 550, y: 370, width: 25, height: 35, collected: false, 
                  type: 'health_potion', value: 0, color: '#FF1493', effect: 'heal' }
            ];
            
            // No immediate enemies - they will spawn when player encounters them
            const page3Enemies = [];
            
            // Add Page 3 trees for atmosphere
            const page3Trees = [
                { x: pageOffset + 100, y: 250, height: 300, type: 'dark' },
                { x: pageOffset + 300, y: 200, height: 350, type: 'dead' },
                { x: pageOffset + 600, y: 220, height: 330, type: 'dark' },
                { x: pageOffset + 900, y: 180, height: 370, type: 'dead' },
                { x: pageOffset + 1200, y: 240, height: 310, type: 'dark' },
                { x: pageOffset + 1400, y: 190, height: 360, type: 'dead' }
            ];
            
            // Add Page 3 obstacles for challenge
            const page3Obstacles = [
                { x: pageOffset + 150, y: 530, width: 40, height: 20, type: 'shadow_spikes', animFrame: 0 },
                { x: pageOffset + 350, y: 530, width: 40, height: 20, type: 'dark_crystal', animFrame: 0 },
                { x: pageOffset + 550, y: 530, width: 40, height: 20, type: 'shadow_spikes', animFrame: 0 },
                { x: pageOffset + 750, y: 530, width: 40, height: 20, type: 'void_trap', animFrame: 0 },
                { x: pageOffset + 950, y: 530, width: 40, height: 20, type: 'dark_crystal', animFrame: 0 },
                { x: pageOffset + 1150, y: 530, width: 40, height: 20, type: 'shadow_spikes', animFrame: 0 }
            ];
            
            // Add Page 3 atmospheric particles/clouds
            const page3Clouds = [
                { x: pageOffset + 200, y: 80, width: 120, height: 60, speed: 0.2, type: 'dark' },
                { x: pageOffset + 500, y: 60, width: 140, height: 70, speed: 0.15, type: 'storm' },
                { x: pageOffset + 800, y: 90, width: 110, height: 55, speed: 0.25, type: 'dark' },
                { x: pageOffset + 1100, y: 70, width: 130, height: 65, speed: 0.18, type: 'storm' },
                { x: pageOffset + 1400, y: 85, width: 115, height: 60, speed: 0.22, type: 'dark' }
            ];
            
            // Add to game arrays
            forestGame.platforms = forestGame.platforms.concat(page3Platforms);
            forestGame.collectibles = forestGame.collectibles.concat(page3Collectibles);
            forestGame.trees = forestGame.trees.concat(page3Trees);
            forestGame.obstacles = forestGame.obstacles.concat(page3Obstacles);
            forestGame.clouds = forestGame.clouds.concat(page3Clouds);
            
            // Initialize enemies array if it doesn't exist
            if (!forestGame.enemies) {
                forestGame.enemies = [];
            }
            // Don't add enemies initially - they will be spawned when encountered
            
            console.log('Combat Arena created successfully!');
        }

        function setupGameControls() {
            document.addEventListener('keydown', (e) => {
                forestGame.keys[e.key] = true;
                
                // Prevent default for game controls
                if (['ArrowLeft', 'ArrowRight', 'ArrowUp', ' ', 'Enter'].includes(e.key)) {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                forestGame.keys[e.key] = false;
            });
        }

        function forestGameLoop() {
            if (!forestGame.running) return;
            
            updateForestGame();
            renderForestGame();
            
            forestGame.animationId = requestAnimationFrame(forestGameLoop);
        }

        function spawnEnemiesIfNeeded() {
            // Initialize enemy persistence data if not exists
            if (!forestGame.enemyPersistence) {
                forestGame.enemyPersistence = {
                    birds: [],
                    boss: null,
                    birdsSpawned: false,
                    bossSpawned: false
                };
            }
            
            // Spawn initial birds when page 3 is first accessed
            if (forestGame.currentPage === 3 && !forestGame.enemyPersistence.birdsSpawned) {
                console.log('Spawning persistent enemies in combat arena!');
                const pageOffset = forestGame.pageWidth * 2;
                
                // Create persistent bird data with unique IDs
                forestGame.enemyPersistence.birds = [
                    { id: 'bird_1', x: pageOffset + 300, y: 400, width: 25, height: 20, type: 'bird', velocityX: 1, velocityY: 0, health: 1, maxHealth: 1, alive: true },
                    { id: 'bird_2', x: pageOffset + 600, y: 350, width: 25, height: 20, type: 'bird', velocityX: -1, velocityY: 0, health: 1, maxHealth: 1, alive: true },
                    { id: 'bird_3', x: pageOffset + 900, y: 380, width: 25, height: 20, type: 'bird', velocityX: 1, velocityY: 0, health: 1, maxHealth: 1, alive: true },
                    { id: 'bird_4', x: pageOffset + 450, y: 320, width: 25, height: 20, type: 'bird', velocityX: 1, velocityY: 0, health: 1, maxHealth: 1, alive: true },
                    { id: 'bird_5', x: pageOffset + 750, y: 300, width: 25, height: 20, type: 'bird', velocityX: -1, velocityY: 0, health: 1, maxHealth: 1, alive: true }
                ];
                
                forestGame.enemyPersistence.birdsSpawned = true;
                forestGame.enemiesSpawned = true;
            }
            
            // Restore alive birds to active enemies array when entering page 3
            if (forestGame.currentPage === 3 && forestGame.enemyPersistence.birdsSpawned) {
                // Only restore if enemies array is empty (avoid duplicates)
                if (forestGame.enemies.length === 0) {
                    // Add alive birds
                    forestGame.enemyPersistence.birds.forEach((bird, index) => {
                        if (bird.alive) {
                            const birdClone = {...bird};
                            // Ensure birds have proper movement velocities
                            if (!birdClone.velocityX) birdClone.velocityX = Math.random() > 0.5 ? 1 : -1;
                            if (!birdClone.velocityY) birdClone.velocityY = Math.random() * 0.5 - 0.25;
                            forestGame.enemies.push(birdClone);
                            console.log(`Restored bird ${bird.id} (index ${index}) to active enemies`);
                        } else {
                            console.log(`Bird ${bird.id} (index ${index}) is dead - not restoring`);
                        }
                    });
                    
                    // Add boss if it exists and is alive
                    if (forestGame.enemyPersistence.boss && forestGame.enemyPersistence.boss.alive) {
                        forestGame.enemies.push({...forestGame.enemyPersistence.boss});
                    }
                    
                    console.log(`Restored ${forestGame.enemies.length} enemies to page 3`);
                }
            }
            
            // Spawn boss when all birds are defeated
            const aliveBirds = forestGame.enemyPersistence.birds.filter(bird => bird.alive).length;
            const totalBirds = forestGame.enemyPersistence.birds.length;
            
            // Debug boss spawn conditions
            if (forestGame.currentPage === 3) {
                console.log(`Boss spawn check: Page=${forestGame.currentPage}, BirdsSpawned=${forestGame.enemyPersistence.birdsSpawned}, BossSpawned=${forestGame.enemyPersistence.bossSpawned}, AliveBirds=${aliveBirds}/${totalBirds}`);
            }
            
            if (forestGame.currentPage === 3 && forestGame.enemyPersistence.birdsSpawned && 
                !forestGame.enemyPersistence.bossSpawned && aliveBirds === 0) {
                console.log(`🔥 SPAWNING BOSS! All ${totalBirds} birds defeated!`);
                const pageOffset = forestGame.pageWidth * 2;
                
                forestGame.enemyPersistence.boss = {
                    id: 'forest_guardian', x: pageOffset + 700, y: 300, width: 60, height: 80, type: 'boss_guardian',
                    velocityX: 0.5, velocityY: 0, health: 5, maxHealth: 5,
                    attackTimer: 0, attackCooldown: 0, phase: 1, alive: true
                };
                
                forestGame.enemies.push({...forestGame.enemyPersistence.boss});
                forestGame.enemyPersistence.bossSpawned = true;
                forestGame.bossSpawned = true;
                createScorePopup(pageOffset + 700, 250, 'FOREST GUARDIAN AWAKENS!', '#FF0000');
            }
        }
        
        function updateEnemies() {
            // Check if we need to spawn enemies
            spawnEnemiesIfNeeded();
            
            // Update all enemies
            const currentEnemies = forestGame.enemies || [];
            for (let i = 0; i < currentEnemies.length; i++) {
                const enemy = currentEnemies[i];
                
                // Update enemy position
                enemy.x += enemy.velocityX;
                enemy.y += enemy.velocityY;
                
                // Apply physics to flying enemies (birds)
                if (enemy.type === 'bird') {
                    // Flapping motion - counter gravity with occasional flaps
                    if (Math.random() < 0.05) { // 5% chance per frame to flap
                        enemy.velocityY -= 1.5; // Strong upward flap
                    } else {
                        enemy.velocityY += 0.15; // Lighter gravity for birds
                    }
                    
                    // Aggressive AI: actively hunt the player
                    const distanceToPlayer = Math.sqrt(
                        Math.pow(enemy.x - forestGame.player.x, 2) + 
                        Math.pow(enemy.y - forestGame.player.y, 2)
                    );
                    
                    if (distanceToPlayer < 400) {
                        // Move towards player horizontally
                        if (forestGame.player.x > enemy.x) {
                            enemy.velocityX = Math.min(enemy.velocityX + 0.15, 2.5);
                        } else {
                            enemy.velocityX = Math.max(enemy.velocityX - 0.15, -2.5);
                        }
                        
                        // Move towards player vertically (diving attack)
                        if (forestGame.player.y > enemy.y && Math.random() < 0.02) {
                            enemy.velocityY += 1; // Dive attack
                        }
                    } else {
                        // Patrol behavior when player is far
                        if (Math.random() < 0.01) {
                            enemy.velocityX = Math.random() * 2 - 1; // Random direction
                        }
                    }
                    
                    // Keep birds in reasonable bounds with bouncing
                    if (enemy.y > forestGame.canvas.height - 120) {
                        enemy.velocityY = -3; // Stronger bounce up
                        enemy.y = forestGame.canvas.height - 120;
                    }
                    if (enemy.y < 30) {
                        enemy.velocityY = 2;
                        enemy.y = 30;
                    }
                    
                    // Horizontal bounds - bounce off page edges
                    const pageOffset = forestGame.pageWidth * 2; // Page 3 offset
                    if (enemy.x < pageOffset + 50) {
                        enemy.velocityX = Math.abs(enemy.velocityX); // Bounce right
                    }
                    if (enemy.x > pageOffset + forestGame.pageWidth - 50) {
                        enemy.velocityX = -Math.abs(enemy.velocityX); // Bounce left
                    }
                } else if (enemy.type === 'boss_guardian') {
                    // Forest Guardian Boss AI
                    const pageOffset = forestGame.pageWidth * 2;
                    const distanceToPlayer = Math.sqrt(
                        Math.pow(enemy.x - forestGame.player.x, 2) + 
                        Math.pow(enemy.y - forestGame.player.y, 2)
                    );
                    
                    // Update animation frame for boss effects
                    if (!enemy.animFrame) enemy.animFrame = 0;
                    enemy.animFrame = (enemy.animFrame + 0.1) % (Math.PI * 2);
                    
                    // Phase 2 triggers at 50% health
                    if (enemy.health <= enemy.maxHealth / 2 && enemy.phase === 1) {
                        enemy.phase = 2;
                        enemy.velocityX *= 1.5; // Faster movement in phase 2
                        createScorePopup(enemy.x, enemy.y - 50, 'BOSS ENRAGED!', '#FF0000');
                    }
                    
                    // Aggressive AI - chase the player
                    if (distanceToPlayer < 500) {
                        // Move towards player horizontally
                        const speed = enemy.phase === 2 ? 1.2 : 0.8;
                        if (forestGame.player.x > enemy.x) {
                            enemy.velocityX = Math.min(enemy.velocityX + 0.05, speed);
                        } else {
                            enemy.velocityX = Math.max(enemy.velocityX - 0.05, -speed);
                        }
                        
                        // Floating motion (vertical hover)
                        enemy.velocityY = Math.sin(enemy.animFrame * 2) * 0.5;
                        
                        // Special attacks
                        if (!enemy.attackTimer) enemy.attackTimer = 0;
                        enemy.attackTimer++;
                        
                        // Phase 1: Charge attack every 180 frames (3 seconds)
                        if (enemy.phase === 1 && enemy.attackTimer > 180) {
                            if (distanceToPlayer < 200) {
                                // Charge at player
                                const dirX = (forestGame.player.x - enemy.x) / distanceToPlayer;
                                enemy.velocityX = dirX * 3;
                                createScorePopup(enemy.x, enemy.y - 30, 'CHARGE!', '#FFA500');
                                enemy.attackTimer = 0;
                            }
                        }
                        
                        // Phase 2: More frequent and aggressive attacks
                        if (enemy.phase === 2 && enemy.attackTimer > 120) {
                            if (distanceToPlayer < 300) {
                                // Teleport attack (instant movement)
                                if (Math.random() < 0.3) {
                                    enemy.x = forestGame.player.x + (Math.random() > 0.5 ? 100 : -100);
                                    createScorePopup(enemy.x, enemy.y - 30, 'TELEPORT!', '#FF00FF');
                                    enemy.attackTimer = 0;
                                }
                            }
                        }
                    } else {
                        // Patrol behavior when player is far
                        enemy.velocityX *= 0.95; // Slow down
                        enemy.velocityY = Math.sin(enemy.animFrame) * 0.3; // Gentle floating
                    }
                    
                    // Keep boss within page bounds
                    if (enemy.x < pageOffset + 100) {
                        enemy.x = pageOffset + 100;
                        enemy.velocityX = Math.abs(enemy.velocityX);
                    }
                    if (enemy.x > pageOffset + forestGame.pageWidth - 160) {
                        enemy.x = pageOffset + forestGame.pageWidth - 160;
                        enemy.velocityX = -Math.abs(enemy.velocityX);
                    }
                    
                    // Keep boss above ground but not too high
                    if (enemy.y > forestGame.canvas.height - 200) {
                        enemy.y = forestGame.canvas.height - 200;
                        enemy.velocityY = -1;
                    }
                    if (enemy.y < 100) {
                        enemy.y = 100;
                        enemy.velocityY = 1;
                    }
                }
                
                // Remove enemies that fall off the world (but protect the boss)
                if (enemy.y > forestGame.canvas.height + 100 && enemy.type !== 'boss_guardian') {
                    currentEnemies.splice(i, 1);
                    i--;
                }
            }
        }
        
        function renderEnemies(ctx) {
            // Render all enemies
            const currentEnemies = forestGame.enemies || [];
            for (const enemy of currentEnemies) {
                if (enemy.type === 'bird') {
                    // Draw bird enemy
                    ctx.fillStyle = '#8B4513'; // Brown color
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    
                    // Draw simple wing details
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(enemy.x + 2, enemy.y + 2, enemy.width - 4, enemy.height - 4);
                    
                    // Draw beak
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(enemy.x + enemy.width - 5, enemy.y + enemy.height/2 - 2, 8, 4);
                } else if (enemy.type === 'boss_guardian') {
                    // Draw Forest Guardian Boss with animations
                    const x = enemy.x;
                    const y = enemy.y;
                    const w = enemy.width;
                    const h = enemy.height;
                    
                    // Animation frame for various effects
                    const animFrame = enemy.animFrame || 0;
                    const breathing = Math.sin(animFrame * 3) * 2; // Breathing effect
                    const auraGlow = Math.sin(animFrame * 4) * 5 + 15; // Pulsing aura
                    
                    // Floating offset
                    const floatOffset = Math.sin(animFrame * 2) * 3;
                    const drawY = y + floatOffset;
                    
                    // Evil aura effect (larger when phase 2)
                    const auraSize = enemy.phase === 2 ? 25 : 15;
                    ctx.shadowColor = enemy.phase === 2 ? '#FF0000' : '#00FF00';
                    ctx.shadowBlur = auraGlow;
                    
                    // Boss body with breathing animation
                    const bodyW = w + breathing;
                    const bodyH = h + breathing * 0.5;
                    const bodyX = x - breathing * 0.5;
                    const bodyY = drawY - breathing * 0.25;
                    
                    ctx.fillStyle = enemy.phase === 2 ? '#8B0000' : '#2F4F2F';
                    ctx.fillRect(bodyX, bodyY, bodyW, bodyH);
                    
                    // Inner body with different animation phase
                    ctx.fillStyle = enemy.phase === 2 ? '#CD5C5C' : '#228B22';
                    const innerOffset = Math.sin(animFrame * 2.5) * 1;
                    ctx.fillRect(bodyX + 5 + innerOffset, bodyY + 5 + innerOffset, bodyW - 10, bodyH - 10);
                    ctx.shadowBlur = 0;
                    
                    // Animated eyes (blinking and glowing)
                    const eyeBlink = Math.sin(animFrame * 0.5) > 0.9 ? 4 : 8; // Blink occasionally
                    const eyeGlow = Math.sin(animFrame * 6) * 2 + 6;
                    ctx.shadowColor = '#FF0000';
                    ctx.shadowBlur = eyeGlow;
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(x + w * 0.2, drawY + h * 0.2, 8, eyeBlink);
                    ctx.fillRect(x + w * 0.6, drawY + h * 0.2, 8, eyeBlink);
                    ctx.shadowBlur = 0;
                    
                    // Animated mouth/fangs
                    const fangLength = 12 + Math.sin(animFrame * 4) * 2; // Growing fangs
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(x + w * 0.3, drawY + h * 0.5, 4, fangLength);
                    ctx.fillRect(x + w * 0.5, drawY + h * 0.5, 4, fangLength);
                    
                    // Animated crown/horns (swaying)
                    const hornSway = Math.sin(animFrame * 1.5) * 2;
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(x + w * 0.1 + hornSway, drawY - 10, 6, 15);
                    ctx.fillRect(x + w * 0.8 - hornSway, drawY - 10, 6, 15);
                    
                    // Phase 2: Additional spikes and effects
                    if (enemy.phase === 2) {
                        ctx.fillStyle = '#8B0000';
                        // Extra spikes
                        ctx.fillRect(x + w * 0.5, drawY - 8, 4, 12);
                        // Rage aura particles
                        for (let i = 0; i < 3; i++) {
                            const particleX = x + Math.random() * w;
                            const particleY = drawY + Math.random() * h;
                            ctx.fillStyle = `rgba(255, ${Math.random() * 100}, 0, 0.7)`;
                            ctx.fillRect(particleX, particleY, 3, 3);
                        }
                    }
                    
                    // Animated health bar
                    const barWidth = w + 10;
                    const barHeight = 10;
                    const healthPercent = enemy.health / enemy.maxHealth;
                    const barX = x - 5;
                    const barY = drawY - 35;
                    
                    // Health bar background with pulse
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Health bar fill with color transition and pulse
                    const healthPulse = Math.sin(animFrame * 8) * 0.1 + 0.9;
                    if (healthPercent > 0.5) {
                        ctx.fillStyle = `rgba(0, 255, 0, ${healthPulse})`;
                    } else if (healthPercent > 0.25) {
                        ctx.fillStyle = `rgba(255, 255, 0, ${healthPulse})`;
                    } else {
                        ctx.fillStyle = `rgba(255, 0, 0, ${healthPulse})`;
                    }
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    // Health bar border with glow
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    // Boss name with color animation
                    const nameColor = enemy.phase === 2 ? 
                        `hsl(${Math.sin(animFrame * 5) * 30 + 15}, 100%, 50%)` : '#FFD700';
                    ctx.fillStyle = nameColor;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = enemy.phase === 2 ? '#FF0000' : '#000000';
                    ctx.shadowBlur = 3;
                    ctx.fillText(enemy.phase === 2 ? 'ENRAGED GUARDIAN' : 'FOREST GUARDIAN', x + w/2, barY - 8);
                    ctx.shadowBlur = 0;
                    ctx.textAlign = 'left';
                    
                    // Debug info (remove this later)
                    if (Math.random() < 0.01) {
                        console.log(`🎨 Boss rendered: Phase ${enemy.phase}, Health ${enemy.health}/${enemy.maxHealth}, Pos (${Math.round(x)}, ${Math.round(drawY)})`);
                    }
                }
            }
        }

        function updateForestGame() {
            updatePlayer();
            updateCamera();
            updateClouds();
            updateObstacles();
            updateCrumblingTiles();
            updateMovingPlatforms();
            updateParticles();
            updateEnemies();
            checkCollisions();
            checkCollectibles();
            updateScorePopups();
            
            // Debug: Log enemy count occasionally and check for stuck state
            if (Math.random() < 0.02 && forestGame.currentPage === 3) { // Increased frequency
                const aliveBirds = forestGame.enemyPersistence?.birds?.filter(b => b.alive).length || 0;
                const totalBirds = forestGame.enemyPersistence?.birds?.length || 0;
                console.log(`📊 Page 3 Status: Active enemies=${forestGame.enemies.length}, Birds alive=${aliveBirds}/${totalBirds}, Boss spawned=${forestGame.enemyPersistence?.bossSpawned}`);
                
                // Force boss spawn if no enemies and no birds alive but boss not spawned (stuck state)
                if (forestGame.enemies.length === 0 && aliveBirds === 0 && totalBirds > 0 &&
                    forestGame.enemyPersistence?.birdsSpawned && !forestGame.enemyPersistence?.bossSpawned) {
                    console.log('🚨 DETECTED STUCK STATE - All birds dead but no boss! Force spawning boss!');
                    spawnEnemiesIfNeeded();
                }
                
                // Also trigger if somehow we have active enemies but they don't match persistence
                if (forestGame.enemies.length > 0 && aliveBirds === 0 && !forestGame.enemyPersistence?.bossSpawned) {
                    console.log('🔄 Mismatched state detected - checking boss spawn...');
                    spawnEnemiesIfNeeded();
                }
            }
        }
        
        function updateObstacles() {
            forestGame.obstacles.forEach(obstacle => {
                obstacle.animFrame = (obstacle.animFrame + 0.2) % 4;
            });
        }
        
        function updateCrumblingTiles() {
            forestGame.crumblingTiles.forEach(tile => {
                if (tile.crumbling) {
                    tile.integrity -= 2;
                    if (tile.integrity <= 0) {
                        // Remove crumbled tile
                        tile.width = 0;
                        tile.height = 0;
                    }
                }
            });
        }
        
        function updateMovingPlatforms() {
            forestGame.movingPlatforms.forEach(platform => {
                // Move platform
                platform.x += platform.vx;
                
                // Bounce at boundaries
                if (platform.x <= platform.minX || platform.x + platform.width >= platform.maxX) {
                    platform.vx = -platform.vx;
                }
            });
        }
        
        function updateParticles() {
            forestGame.particles = forestGame.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1; // Gravity
                particle.life--;
                return particle.life > 0;
            });
        }
        
        function createCollectionParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                forestGame.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 2,
                    size: 3 + Math.random() * 2,
                    color: color,
                    life: 30,
                    maxLife: 30
                });
            }
        }
        
        function createBossHitEffect(x, y) {
            // Create boss hit impact particles
            for (let i = 0; i < 12; i++) {
                forestGame.particles.push({
                    x: x + Math.random() * 20 - 10,
                    y: y + Math.random() * 20 - 10,
                    velocityX: Math.random() * 10 - 5,
                    velocityY: Math.random() * 10 - 5,
                    color: '#FF4500',
                    life: 30,
                    maxLife: 30,
                    size: Math.random() * 6 + 3
                });
            }
        }
        
        function createDeathParticles(x, y) {
            // Create dramatic death particles when player dies in marsh
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2;
                const speed = 3 + Math.random() * 4;
                forestGame.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 3,
                    size: 4 + Math.random() * 3,
                    color: '#8B0000', // Dark red death particles
                    life: 40,
                    maxLife: 40
                });
            }
        }
        
        function createSwordSlashEffect(x, y) {
            // Create sword slash particles
            for (let i = 0; i < 6; i++) {
                forestGame.particles.push({
                    x: x + Math.random() * 40 - 20,
                    y: y + Math.random() * 30 - 15,
                    velocityX: Math.random() * 6 - 3,
                    velocityY: Math.random() * 4 - 2,
                    color: '#87CEEB', // Light blue sword slash
                    life: 15,
                    maxLife: 15,
                    size: Math.random() * 3 + 2
                });
            }
        }
        
        function createLegendarySwordParticles(x, y) {
            // Epic golden particles for finding the Sword of Azureon
            for (let i = 0; i < 25; i++) {
                const angle = (i / 25) * Math.PI * 2;
                const speed = 4 + Math.random() * 5;
                forestGame.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 4,
                    size: 5 + Math.random() * 4,
                    color: i % 2 === 0 ? '#FFD700' : '#FFA500', // Alternating gold colors
                    life: 60,
                    maxLife: 60
                });
            }
        }
        
        function spawnForestRelic() {
            console.log('🌟 spawnForestRelic() called');
            const pageOffset = forestGame.pageWidth * 2;
            console.log('📍 Page offset calculated:', pageOffset);
            const relic = {
                x: pageOffset + 800, y: 400, width: 50, height: 50, collected: false,
                type: 'forest_relic', value: 5000, color: '#00FF7F', effect: 'forest_relic',
                glowTimer: 0, pulseIntensity: 1
            };
            console.log('🎯 Forest Relic created at:', relic.x, relic.y);
            forestGame.collectibles.push(relic);
            console.log('📦 Total collectibles now:', forestGame.collectibles.length);
            createScorePopup(relic.x, relic.y - 40, 'FOREST RELIC APPEARED!', '#00FF7F');
            
            // Show instruction message after relic appears
            setTimeout(() => {
                createInstructionAlert(
                    '🌟 THE FOREST RELIC HAS APPEARED! 🌟',
                    '🏃‍♂️ Move to collect it and unlock the exit portal!'
                );
            }, 500);
        }
        
        function createForestExit() {
            console.log('🚪 createForestExit() called');
            const pageOffset = forestGame.pageWidth * 2;
            console.log('📍 Exit page offset:', pageOffset);
            const exit = {
                x: pageOffset + forestGame.pageWidth - 80, y: 350, width: 70, height: 120, collected: false,
                type: 'forest_exit', value: 0, color: '#9370DB', effect: 'level_complete',
                glowTimer: 0, portalEffect: 0
            };
            console.log('🎯 Forest Exit created at:', exit.x, exit.y);
            forestGame.collectibles.push(exit);
            console.log('📦 Total collectibles after exit creation:', forestGame.collectibles.length);
            createScorePopup(exit.x, exit.y - 40, 'FOREST EXIT OPENED!', '#9370DB');
            console.log('🚪 Forest Exit created at extreme right of page 3');
        }

        function updatePlayer() {
            const player = forestGame.player;
            
            // Update invulnerability
            if (player.invulnerable) {
                player.invulnerabilityTimer--;
                if (player.invulnerabilityTimer <= 0) {
                    player.invulnerable = false;
                }
            }
            
            // Horizontal movement with animation states
            if (forestGame.keys['ArrowLeft']) {
                player.velocityX = -player.speed;
                player.direction = -1;
                if (player.onGround) player.state = 'running';
            } else if (forestGame.keys['ArrowRight']) {
                player.velocityX = player.speed;
                player.direction = 1;
                if (player.onGround) player.state = 'running';
            } else {
                player.velocityX *= 0.8; // Friction
                if (player.onGround && Math.abs(player.velocityX) < 0.5) {
                    player.state = 'idle';
                }
            }
            
            // Jumping (but not when climbing ropes)
            if ((forestGame.keys['ArrowUp'] || forestGame.keys[' ']) && player.onGround && 
                player.state !== 'climbing' && player.state !== 'hanging') {
                player.velocityY = -player.jumpPower;
                player.onGround = false;
                player.state = 'jumping';
            }
            
            // Handle sword attacks (Shift key)
            if (forestGame.keys['Shift'] && forestGame.swordFound && !player.attacking && player.attackCooldown <= 0) {
                player.attacking = true;
                player.attackTimer = 15; // Attack duration (frames)
                player.attackCooldown = 30; // Cooldown between attacks
                
                // Visual sword slash effect
                createSwordSlashEffect(player.x + player.width/2, player.y + player.height/2);
                console.log(`⚔️ SWORD ATTACK initiated`);
                
                // Attack enemies within reach
                const currentEnemies = forestGame.enemies || [];
                for (let i = currentEnemies.length - 1; i >= 0; i--) {
                    const enemy = currentEnemies[i];
                    
                    // Simple collision detection for birds, enhanced for boss
                    let distance, verticalDistance;
                    let maxDistance, maxVerticalDistance;
                    
                    if (enemy.type === 'boss_guardian') {
                        // Enhanced collision detection for boss
                        const playerCenterX = player.x + player.width / 2;
                        const playerCenterY = player.y + player.height / 2;
                        const enemyCenterX = enemy.x + enemy.width / 2;
                        const enemyCenterY = enemy.y + enemy.height / 2;
                        
                        distance = Math.abs(enemyCenterX - playerCenterX);
                        verticalDistance = Math.abs(enemyCenterY - playerCenterY);
                        maxDistance = 120; // Larger range for boss
                        maxVerticalDistance = 100; // More vertical tolerance for floating boss
                    } else {
                        // Simple collision detection for birds (enhanced range)
                        distance = Math.abs(enemy.x - player.x);
                        verticalDistance = Math.abs(enemy.y - player.y);
                        maxDistance = player.swordReach;
                        maxVerticalDistance = 90; // Increased vertical range for easier bird combat
                    }
                    
                    if (distance <= maxDistance && verticalDistance <= maxVerticalDistance) {
                        // Enemy hit!
                        if (!enemy.health) enemy.health = 1; // Default health for old enemies
                        enemy.health -= 1;
                        
                        if (enemy.type === 'boss_guardian') {
                            createScorePopup(enemy.x, enemy.y - 30, `BOSS HIT! ${enemy.health}/${enemy.maxHealth}`, '#FF6B35');
                            updateScore(50);
                            
                            // Visual feedback for boss hit
                            createBossHitEffect(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            
                            // Screen shake for boss hits
                            if (forestGame.camera) {
                                forestGame.camera.shakeTimer = 10;
                                forestGame.camera.shakeIntensity = 5;
                            }
                            
                            console.log(`💥 BOSS HIT! Health: ${enemy.health}/${enemy.maxHealth}`);
                            
                            // Update boss health in persistence
                            if (forestGame.enemyPersistence && forestGame.enemyPersistence.boss) {
                                forestGame.enemyPersistence.boss.health = enemy.health;
                            }
                            
                            if (enemy.health <= 0) {
                                createScorePopup(enemy.x, enemy.y - 50, 'FOREST GUARDIAN DEFEATED!', '#FFD700');
                                createLegendarySwordParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                currentEnemies.splice(i, 1);
                                updateScore(1000);
                                
                                // Mark boss as dead in persistence
                                if (forestGame.enemyPersistence && forestGame.enemyPersistence.boss) {
                                    forestGame.enemyPersistence.boss.alive = false;
                                }
                                
                                // Spawn Forest Relic
                                console.log('🏆 Boss defeated! Spawning Forest Relic...');
                                setTimeout(() => {
                                    console.log('⏰ Timeout reached, calling spawnForestRelic()');
                                    spawnForestRelic();
                                    console.log('🌟 Forest Relic spawn completed');
                                }, 1000);
                            }
                        } else {
                            if (enemy.health <= 0) {
                                createScorePopup(enemy.x, enemy.y - 20, 'DEFEATED!', '#FF6B35');
                                createDeathParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                currentEnemies.splice(i, 1);
                                updateScore(100);
                                
                                // Mark bird as dead in persistence using unique ID
                                if (forestGame.enemyPersistence && forestGame.enemyPersistence.birds) {
                                    if (enemy.id) {
                                        const birdIndex = forestGame.enemyPersistence.birds.findIndex(bird => 
                                            bird.id === enemy.id && bird.alive
                                        );
                                        if (birdIndex !== -1) {
                                            forestGame.enemyPersistence.birds[birdIndex].alive = false;
                                            const remaining = forestGame.enemyPersistence.birds.filter(b => b.alive).length;
                                            console.log(`🎯 Bird ${enemy.id} marked as dead! Remaining alive birds: ${remaining}`);
                                            
                                            // Force boss spawn check if no birds left
                                            if (remaining === 0) {
                                                console.log(`🔥 LAST BIRD DEFEATED! Triggering boss spawn...`);
                                                setTimeout(() => spawnEnemiesIfNeeded(), 100);
                                            }
                                        } else {
                                            console.warn(`❌ Could not find living bird with ID ${enemy.id} to mark as dead`);
                                            console.log('Available birds:', forestGame.enemyPersistence.birds.map(b => `${b.id}:${b.alive}`));
                                        }
                                    } else {
                                        console.error(`❌ Enemy has no ID! Type: ${enemy.type}, Position: (${enemy.x}, ${enemy.y})`);
                                        // Fallback: try to match by position (less reliable)
                                        const nearbyBird = forestGame.enemyPersistence.birds.find(bird => 
                                            bird.alive && Math.abs(bird.x - enemy.x) < 100
                                        );
                                        if (nearbyBird) {
                                            nearbyBird.alive = false;
                                            console.log(`🔧 Fallback: Marked nearby bird ${nearbyBird.id} as dead`);
                                        }
                                    }
                                }
                            } else {
                                createScorePopup(enemy.x, enemy.y - 20, 'HIT!', '#FFA500');
                            }
                        }
                    }
                }
            }
            
            // Update attack timers
            if (player.attacking) {
                player.attackTimer--;
                if (player.attackTimer <= 0) {
                    player.attacking = false;
                }
            }
            if (player.attackCooldown > 0) {
                player.attackCooldown--;
            }
            
            // Update animation state based on movement
            if (!player.onGround) {
                if (player.velocityY < 0) {
                    player.state = 'jumping';
                } else {
                    player.state = 'falling';
                }
            } else if (player.state === 'climbing' || player.state === 'hanging') {
                // Keep climbing/hanging state when on rope
            }
            
            // Update animation frame
            player.animTimer++;
            if (player.animTimer >= player.animSpeed) {
                player.animTimer = 0;
                player.animFrame = (player.animFrame + 1) % 4;
            }
            
            // Apply gravity
            player.velocityY += 0.8;
            
            // Apply velocities
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Ground collision with regular platforms and rope climbing
            player.onGround = false;
            forestGame.platforms.forEach(platform => {
                if (platform.type === 'rope') {
                    // Rope climbing mechanics
                    if (isColliding(player, platform)) {
                        // Player can climb up/down on rope
                        if (forestGame.keys['ArrowUp']) {
                            player.velocityY = -4; // Climb up
                            player.onGround = true;
                            player.state = 'climbing';
                        } else if (forestGame.keys['ArrowDown'] && player.y < platform.y + platform.height - player.height) {
                            player.velocityY = 2; // Climb down
                            player.onGround = true;
                            player.state = 'climbing';
                        } else {
                            // Hanging on rope - no gravity
                            player.velocityY = 0;
                            player.onGround = true;
                            player.state = 'hanging';
                        }
                        // Allow horizontal movement while on rope (reduced speed)
                        if (forestGame.keys['ArrowLeft'] || forestGame.keys['ArrowRight']) {
                            player.velocityX *= 0.7;
                        } else {
                            player.velocityX *= 0.9; // Gradual stop when not moving
                        }
                    }
                } else if (isColliding(player, platform) && player.velocityY > 0) {
                    // Regular platform collision
                    if (player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                    }
                }
            });
            
            // Moving platform collision
            forestGame.movingPlatforms.forEach(platform => {
                if (platform.page && platform.page !== forestGame.currentPage) return;
                
                if (isColliding(player, platform) && player.velocityY > 0) {
                    if (player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        // Move player with platform
                        player.x += platform.vx;
                    }
                }
            });
            
            // Crumbling tile collision
            forestGame.crumblingTiles.forEach(tile => {
                if (isColliding(player, tile) && player.velocityY > 0) {
                    if (player.y < tile.y && !tile.crumbling) {
                        player.y = tile.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        
                        // Start crumbling after player steps on it
                        tile.stepCount++;
                        if (tile.stepCount > 30) { // After 30 frames of standing
                            tile.crumbling = true;
                        }
                    }
                }
            });
            
            // Page transition logic with hysteresis to prevent flickering
            const pageWidth = forestGame.pageWidth;
            const totalWidth = forestGame.totalPages * pageWidth;
            
            // Handle page transitions based on player position with wider thresholds
            if (player.x >= pageWidth * 0.95 && forestGame.currentPage === 1) {
                forestGame.currentPage = 2;
                if (!forestGame.page2Created) {
                    createMarshlandsElements();
                    forestGame.page2Created = true;
                }
            } else if (player.x >= pageWidth * 1.9 && forestGame.currentPage === 2) {
                // Only allow access to page 3 if player has found the sword
                if (forestGame.swordFound) {
                    forestGame.currentPage = 3;
                    if (!forestGame.page3Created) {
                        createCombatArenaElements();
                        forestGame.page3Created = true;
                    }
                } else {
                    // Block access - show dramatic message
                    player.x = pageWidth * 1.85;
                    player.velocityX = 0;
                    createScorePopup(player.x, player.y - 40, 'NEED SWORD OF AZUREON!', '#FF4500');
                }
            } else if (player.x <= pageWidth * 0.85 && forestGame.currentPage === 2) {
                forestGame.currentPage = 1;
            } else if (player.x <= pageWidth * 1.8 && forestGame.currentPage === 3) {
                forestGame.currentPage = 2;
            }
            
            // Global boundaries (allow movement across both pages)
            if (player.x < 0) player.x = 0;
            if (player.x > totalWidth - player.width) player.x = totalWidth - player.width;
            
            // Death boundary
            if (player.y > 650) {
                loseLife();
            }
        }

        function updateCamera() {
            const player = forestGame.player;
            const canvas = forestGame.canvas;
            const pageWidth = forestGame.pageWidth;
            const totalWidth = forestGame.totalPages * pageWidth;
            
            // Follow player with some offset
            forestGame.camera.x = player.x - canvas.width / 2;
            
            // Clamp camera to total level boundaries
            if (forestGame.camera.x < 0) forestGame.camera.x = 0;
            if (forestGame.camera.x > totalWidth - canvas.width) forestGame.camera.x = totalWidth - canvas.width;
        }

        function updateClouds() {
            const totalWidth = forestGame.totalPages * forestGame.pageWidth;
            forestGame.clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > totalWidth + 100) {
                    cloud.x = -cloud.width;
                }
            });
        }

        function checkCollisions() {
            const player = forestGame.player;
            
            if (!player.invulnerable) {
                forestGame.obstacles.forEach(obstacle => {
                    if (isColliding(player, obstacle)) {
                        loseLife();
                    }
                });
                
                // Check enemy collisions
                const currentEnemies = forestGame.enemies || [];
                currentEnemies.forEach(enemy => {
                    if (isColliding(player, enemy)) {
                        // Create hit particles
                        createDeathParticles(player.x + player.width/2, player.y + player.height/2);
                        loseLife();
                    }
                });
            }
            
            // Check deadly marsh collisions (instant death)  
            forestGame.marshes.forEach(marsh => {
                if (isColliding(player, marsh)) {
                    // Create death particles
                    createDeathParticles(player.x + player.width/2, player.y + player.height/2);
                    loseLife(); // Instant death in marshes
                }
            });
        }

        function checkCollectibles() {
            const player = forestGame.player;
            
            forestGame.collectibles.forEach(collectible => {
                if (!collectible.collected && isColliding(player, collectible)) {
                    collectible.collected = true;
                    
                    // Handle different collectible effects
                    if (collectible.effect === 'heal') {
                        if (gameState.lives < 3) {
                            gameState.lives++;
                            updateLifeDisplay();
                            createScorePopup(collectible.x, collectible.y, '+1 Life', '#FF1493');
                        } else {
                            createScorePopup(collectible.x, collectible.y, 'Full Health!', '#FF1493');
                        }
                    } else if (collectible.effect === 'speed') {
                        player.speed = 9; // Temporary speed boost
                        player.jumpPower = 18;
                        setTimeout(() => {
                            player.speed = 6;
                            player.jumpPower = 15;
                        }, 5000); // 5 second boost
                        createScorePopup(collectible.x, collectible.y, 'Speed Boost!', '#00BFFF');
                    } else if (collectible.effect === 'legendary_weapon') {
                        // Player found the Sword of Azureon!
                        forestGame.swordFound = true;
                        updateScore(collectible.value);
                        createScorePopup(collectible.x, collectible.y, 'SWORD OF AZUREON!', '#FFD700');
                        createLegendarySwordParticles(collectible.x + collectible.width/2, collectible.y + collectible.height/2);
                        
                        // Enhance player abilities permanently
                        player.speed = 8; // Permanent speed increase
                        player.jumpPower = 17; // Higher jumps
                        
                        // Enhanced sword discovery instruction
                        setTimeout(() => {
                            createInstructionAlert(
                                '🗡️ SWORD OF AZUREON OBTAINED! 🗡️',
                                '⚔️ Press SHIFT to attack enemies! The Combat Arena awaits!'
                            );
                        }, 1000);
                        
                        // Victory celebration with enhanced instruction message
                        setTimeout(() => {
                            createInstructionAlert(
                                '🗡️ SWORD OF AZUREON OBTAINED! 🗡️',
                                '⚔️ Press SHIFT to attack enemies! The Combat Arena awaits!',
                                'epic'
                            );
                        }, 100);
                    } else if (collectible.effect === 'forest_relic') {
                        // Forest Relic collected
                        console.log('🌟 FOREST RELIC COLLECTED! Creating exit...');
                        gameState.hasForestRelic = true;
                        updateScore(collectible.value);
                        createScorePopup(collectible.x, collectible.y, 'FOREST RELIC OBTAINED!', '#00FF7F');
                        createScorePopup(collectible.x, collectible.y - 30, '+5000 POINTS!', '#FFD700');
                        updateLifeDisplay();
                        
                        // Create legendary particles
                        createLegendarySwordParticles(collectible.x + collectible.width/2, collectible.y + collectible.height/2);
                        
                        // Show exit instruction and create exit
                        console.log('⏰ Setting timeout for exit creation...');
                        setTimeout(() => {
                            console.log('🚪 Creating instruction alert and forest exit');
                            createInstructionAlert(
                                '🌟 FOREST RELIC OBTAINED! 🌟',
                                '🚪 Forest Exit opened at the far right! Move there to complete Level 1!'
                            );
                            createForestExit();
                            console.log('✅ Forest exit creation completed');
                        }, 1000);
                    } else if (collectible.effect === 'level_complete') {
                        // Level completion - show level complete screen
                        showLevelCompleteScreen();
                    } else {
                        updateScore(collectible.value);
                        createScorePopup(collectible.x, collectible.y, '+' + collectible.value, collectible.color);
                    }
                    
                    // Create particle effect
                    createCollectionParticles(collectible.x + collectible.width/2, collectible.y + collectible.height/2, collectible.color);
                    
                    // Update HUD
                    updateGameHUD();
                }
            });
        }

        function createInstructionAlert(title, instruction, type = 'instruction') {
            // Create a prominent instruction overlay that disappears after 2 seconds
            const alertDiv = document.createElement('div');
            alertDiv.className = 'instruction-alert';
            alertDiv.innerHTML = `
                <div class="instruction-content">
                    <div class="instruction-title">${title}</div>
                    <div class="instruction-text">${instruction}</div>
                    <div class="instruction-timer"></div>
                </div>
            `;
            
            // Style the alert
            alertDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
                border: 4px solid #d4af37;
                border-radius: 20px;
                padding: 30px 40px;
                z-index: 3000;
                box-shadow: 0 0 50px rgba(212, 175, 55, 0.8), inset 0 0 30px rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                animation: instructionAppear 0.3s ease-out;
                max-width: 600px;
                text-align: center;
                font-family: 'Cinzel', serif;
            `;
            
            document.body.appendChild(alertDiv);
            
            // Add CSS for the instruction alert if not already added
            if (!document.getElementById('instruction-alert-styles')) {
                const style = document.createElement('style');
                style.id = 'instruction-alert-styles';
                style.textContent = `
                    @keyframes instructionAppear {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    }
                    
                    @keyframes instructionDisappear {
                        0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                    
                    .instruction-title {
                        font-size: 28px;
                        font-weight: bold;
                        color: #d4af37;
                        margin-bottom: 15px;
                        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
                        animation: titleGlow 2s ease-in-out infinite alternate;
                    }
                    
                    .instruction-text {
                        font-size: 20px;
                        color: #ffffff;
                        margin-bottom: 20px;
                        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
                        line-height: 1.4;
                    }
                    
                    .instruction-timer {
                        height: 4px;
                        background: linear-gradient(90deg, #d4af37, #ffd700);
                        border-radius: 2px;
                        animation: timerCountdown 2s linear;
                    }
                    
                    @keyframes titleGlow {
                        0% { text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); }
                        100% { text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7), 0 0 20px #d4af37; }
                    }
                    
                    @keyframes timerCountdown {
                        0% { width: 100%; }
                        100% { width: 0%; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Auto-remove after 2 seconds with fade out animation
            setTimeout(() => {
                alertDiv.style.animation = 'instructionDisappear 0.3s ease-in';
                setTimeout(() => {
                    if (document.body.contains(alertDiv)) {
                        document.body.removeChild(alertDiv);
                    }
                }, 300);
            }, 2000);
            
            console.log('Created instruction alert:', title);
        }

        function createScorePopup(x, y, value, color = '#FFD700') {
            forestGame.scorePopups.push({
                x: x,
                y: y,
                value: value,
                color: color,
                life: 60,
                maxLife: 60
            });
        }

        function updateScorePopups() {
            for (let i = forestGame.scorePopups.length - 1; i >= 0; i--) {
                const popup = forestGame.scorePopups[i];
                popup.life--;
                popup.y -= 1;
                
                if (popup.life <= 0) {
                    forestGame.scorePopups.splice(i, 1);
                }
            }
        }

        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function loseLife() {
            gameState.lives--;
            updateLifeDisplay();
            
            // Add invulnerability period
            forestGame.player.invulnerable = true;
            forestGame.player.invulnerabilityTimer = 120; // 2 seconds at 60fps
            
            if (gameState.lives <= 0) {
                gameOver();
            } else {
                // Smart respawn - keep player in same page if in combat
                if (forestGame.currentPage === 3 && (forestGame.enemiesSpawned || forestGame.bossSpawned)) {
                    // Respawn in page 3 combat arena but at safe position
                    const pageOffset = forestGame.pageWidth * 2;
                    forestGame.player.x = pageOffset + 100;
                    forestGame.player.y = 450;
                } else {
                    // Normal respawn at beginning
                    forestGame.player.x = 100;
                    forestGame.player.y = 400;
                    forestGame.currentPage = 1;
                }
                
                forestGame.player.velocityX = 0;
                forestGame.player.velocityY = 0;
                
                createScorePopup(forestGame.player.x, forestGame.player.y - 30, 'Ouch!', '#FF0000');
            }
        }

        function updateLifeDisplay() {
            for (let i = 1; i <= 3; i++) {
                const heart = document.getElementById(`life${i}`);
                if (heart) {
                    if (i <= gameState.lives) {
                        heart.classList.remove('lost');
                    } else {
                        heart.classList.add('lost');
                    }
                }
            }
            
            // Update Forest Relic indicator
            const relicIndicator = document.getElementById('forestRelicIndicator');
            if (relicIndicator) {
                if (gameState.hasForestRelic) {
                    relicIndicator.style.display = 'inline-block';
                } else {
                    relicIndicator.style.display = 'none';
                }
            }
        }

        function gameOver() {
            console.log('Game Over triggered - stopping game');
            forestGame.running = false;
            if (forestGame.animationId) {
                cancelAnimationFrame(forestGame.animationId);
                forestGame.animationId = null;
            }
            
            // Clear any existing retry listeners to avoid conflicts
            document.removeEventListener('keydown', handleRetryInput);
            
            // Small delay to ensure game loop stops before showing retry page
            setTimeout(() => {
                showRetryPage();
            }, 100);
        }
        
        function showRetryPage() {
            console.log('Showing retry page');
            const canvas = forestGame.canvas;
            const ctx = forestGame.ctx;
            
            // Ensure game is really stopped
            forestGame.running = false;
            if (forestGame.animationId) {
                cancelAnimationFrame(forestGame.animationId);
                forestGame.animationId = null;
            }
            
            // Pre-calculate static elements for better performance
            let staticStars = [];
            if (staticStars.length === 0) {
                for (let i = 0; i < 100; i++) {
                    staticStars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        brightness: Math.random(),
                        speed: 0.5 + Math.random() * 0.5
                    });
                }
            }
            
            function renderRetryPage() {
                const time = Date.now() * 0.001;
                
                // Create dramatic fantasy background
                const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                bgGradient.addColorStop(0, '#0a0a2e');
                bgGradient.addColorStop(0.3, '#1a0f2e');
                bgGradient.addColorStop(0.7, '#2e1a1a');
                bgGradient.addColorStop(1, '#000000');
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add mystical fog effect
                for (let i = 0; i < 5; i++) {
                    const fogX = Math.sin(time * 0.5 + i) * 200 + canvas.width / 2;
                    const fogY = canvas.height * 0.8 + Math.cos(time * 0.3 + i) * 50;
                    const fogRadius = 150 + Math.sin(time + i) * 30;
                    
                    const fogGradient = ctx.createRadialGradient(fogX, fogY, 0, fogX, fogY, fogRadius);
                    fogGradient.addColorStop(0, 'rgba(100, 100, 150, 0.3)');
                    fogGradient.addColorStop(1, 'rgba(100, 100, 150, 0)');
                    ctx.fillStyle = fogGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                // Animated mystical stars and embers
                staticStars.forEach((star, index) => {
                    const twinkle = Math.sin(time * star.speed + star.brightness * 10) * 0.5 + 0.7;
                    const isEmber = index % 4 === 0;
                    
                    if (isEmber) {
                        // Floating embers
                        ctx.fillStyle = `rgba(255, 100, 50, ${twinkle * 0.8})`;
                        const emberSize = 3 + Math.sin(time * 2 + index) * 1;
                        ctx.fillRect(star.x, star.y + Math.sin(time + index) * 20, emberSize, emberSize);
                    } else {
                        // Twinkling stars
                        ctx.fillStyle = `rgba(200, 200, 255, ${twinkle})`;
                        ctx.fillRect(star.x, star.y, 2, 2);
                    }
                });
                
                // Epic Game Over title with magical effects
                const titleY = 110;
                const titlePulse = Math.sin(time * 2) * 0.15 + 1;
                
                // Shadow layers for depth and drama
                ctx.font = 'bold 76px Cinzel, serif';
                ctx.textAlign = 'center';
                
                // Deep shadow for depth
                ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                ctx.fillText('⚰️ THE QUEST ENDS ⚰️', canvas.width / 2 + 5, titleY + 5);
                
                // Crimson glow effect
                ctx.shadowColor = '#DC143C';
                ctx.shadowBlur = 35;
                ctx.fillStyle = '#8B0000';
                ctx.fillText('⚰️ THE QUEST ENDS ⚰️', canvas.width / 2, titleY);
                
                // Golden outline for majesty
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 4;
                ctx.strokeText('⚰️ THE QUEST ENDS ⚰️', canvas.width / 2, titleY);
                
                // Main title with fiery red
                ctx.fillStyle = '#FF1744';
                ctx.fillText('⚰️ THE QUEST ENDS ⚰️', canvas.width / 2, titleY);
                
                // Subtitle with mystical feel
                ctx.font = 'italic 24px Cinzel, serif';
                ctx.fillStyle = '#CCCCCC';
                ctx.shadowColor = '#4169E1';
                ctx.shadowBlur = 10;
                ctx.fillText('The shadows have claimed another hero...', canvas.width / 2, titleY + 50);
                
                // Enhanced score scroll/parchment
                const scrollY = 200;
                const scrollHeight = 160;
                const scrollWidth = canvas.width * 0.7;
                const scrollX = (canvas.width - scrollWidth) / 2;
                
                // Parchment background
                const parchmentGradient = ctx.createLinearGradient(scrollX, scrollY, scrollX + scrollWidth, scrollY + scrollHeight);
                parchmentGradient.addColorStop(0, '#F4E4BC');
                parchmentGradient.addColorStop(0.5, '#E6D3A3');
                parchmentGradient.addColorStop(1, '#D4C4A0');
                ctx.fillStyle = parchmentGradient;
                ctx.fillRect(scrollX, scrollY, scrollWidth, scrollHeight);
                
                // Parchment border with aging effects
                ctx.strokeStyle = '#8B7355';
                ctx.lineWidth = 4;
                ctx.strokeRect(scrollX, scrollY, scrollWidth, scrollHeight);
                
                // Inner decorative border
                ctx.strokeStyle = '#A0522D';
                ctx.lineWidth = 2;
                ctx.strokeRect(scrollX + 10, scrollY + 10, scrollWidth - 20, scrollHeight - 20);
                
                // Score text on parchment
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#2F1B14';
                ctx.font = 'bold 28px Cinzel, serif';
                ctx.fillText('⚔️ FINAL TALLY ⚔️', canvas.width / 2, scrollY + 40);
                
                ctx.font = 'bold 24px Cinzel, serif';
                ctx.fillStyle = '#8B4513';
                ctx.fillText(`🎯 Valor Points Earned: ${gameState.score}`, canvas.width / 2, scrollY + 80);
                ctx.fillText(`👑 Kingdom Glory: ${Math.floor(gameState.score * 1.5)}`, canvas.width / 2, scrollY + 110);
                
                ctx.font = 'italic 20px Cinzel, serif';
                ctx.fillStyle = '#654321';
                ctx.fillText(`"${gameState.playerName} fought with honor, though darkness prevailed..."`, canvas.width / 2, scrollY + 140);
                ctx.shadowBlur = 0;
                
                // Enhanced button styling
                const buttonWidth = 250;
                const buttonHeight = 60;
                const centerX = canvas.width / 2;
                
                // Retry button with enhanced effects
                const retryBtn = { x: centerX - buttonWidth/2, y: 350, width: buttonWidth, height: buttonHeight };
                
                // Button background gradient
                const retryGradient = ctx.createLinearGradient(retryBtn.x, retryBtn.y, retryBtn.x, retryBtn.y + retryBtn.height);
                retryGradient.addColorStop(0, '#00DD00');
                retryGradient.addColorStop(1, '#007700');
                ctx.fillStyle = retryGradient;
                ctx.fillRect(retryBtn.x, retryBtn.y, retryBtn.width, retryBtn.height);
                
                // Animated border glow for retry button
                const glowIntensity = Math.sin(time * 3) * 0.4 + 0.8;
                ctx.strokeStyle = `rgba(0, 255, 0, ${glowIntensity})`;
                ctx.lineWidth = 5;
                ctx.strokeRect(retryBtn.x - 2, retryBtn.y - 2, retryBtn.width + 4, retryBtn.height + 4);
                
                // Retry button text
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 28px Arial';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 3;
                ctx.fillText('🔄 RETRY GAME', centerX, retryBtn.y + 38);
                
                // Title button with enhanced effects
                const titleBtn = { x: centerX - buttonWidth/2, y: 430, width: buttonWidth, height: buttonHeight };
                
                // Button background gradient
                const titleGradient = ctx.createLinearGradient(titleBtn.x, titleBtn.y, titleBtn.x, titleBtn.y + titleBtn.height);
                titleGradient.addColorStop(0, '#FF8800');
                titleGradient.addColorStop(1, '#CC4400');
                ctx.fillStyle = titleGradient;
                ctx.fillRect(titleBtn.x, titleBtn.y, titleBtn.width, titleBtn.height);
                
                // Animated border glow for title button (different phase)
                const glowIntensity2 = Math.sin(time * 3 + 1.5) * 0.4 + 0.8;
                ctx.strokeStyle = `rgba(255, 165, 0, ${glowIntensity2})`;
                ctx.lineWidth = 5;
                ctx.strokeRect(titleBtn.x - 2, titleBtn.y - 2, titleBtn.width + 4, titleBtn.height + 4);
                
                // Title button text
                ctx.fillStyle = '#FFFFFF';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 3;
                ctx.fillText('🏠 TITLE SCREEN', centerX, titleBtn.y + 38);
                ctx.shadowBlur = 0;
                
                // Enhanced keyboard instructions
                ctx.fillStyle = '#CCCCCC';
                ctx.font = 'bold 18px Arial';
                ctx.fillText('Press R (Retry) • T (Title) • ESC (Quit)', centerX, 530);
                
                // Store button positions for click detection
                forestGame.retryButtons = { retry: retryBtn, title: titleBtn };
            }
            
            // Start animation loop for retry page
            function animateRetryPage() {
                renderRetryPage();
                if (gameState.gameOver && !forestGame.running) {
                    requestAnimationFrame(animateRetryPage);
                }
            }
            
            animateRetryPage();
            console.log('Retry buttons created:', forestGame.retryButtons);
            
            // Clean up any existing listeners first
            document.removeEventListener('keydown', handleRetryInput);
            document.removeEventListener('click', handleRetryClick);
            
            console.log('🔧 Setting up retry event listeners...');
            
            // Add event listeners with explicit options
            document.addEventListener('keydown', handleRetryInput, { passive: false });
            document.addEventListener('click', handleRetryClick, { passive: false });
            
            console.log('✅ Retry event listeners added successfully');
            
            // Add a global test listener to see if ANY events are being captured
            const testClickListener = (e) => {
                console.log('🔍 GLOBAL CLICK DETECTED:', e.clientX, e.clientY, e.target);
            };
            const testKeyListener = (e) => {
                console.log('🔍 GLOBAL KEY DETECTED:', e.key, e.code);
            };
            
            document.addEventListener('click', testClickListener, true); // Use capture phase
            document.addEventListener('keydown', testKeyListener, true);
            // Remove test listeners after 10 seconds
            setTimeout(() => {
                document.removeEventListener('click', testClickListener, true);
                document.removeEventListener('keydown', testKeyListener, true);
                console.log('🧹 Test listeners removed');
            }, 10000);
            
            // Test if event listeners are working
            setTimeout(() => {
                console.log('🧪 Testing event listeners - Press R, T, or ESC, or click buttons');
                console.log('📊 Current state:', {
                    gameOver: gameState.gameOver,
                    running: forestGame.running,
                    retryButtons: !!forestGame.retryButtons
                });
            }, 100);
        }
        
        function handleRetryClick(event) {
            console.log('🔄 RETRY BUTTON CLICKED - RESTARTING GAME');
            
            // Simple solution: just restart the game
            restartGameSimple();
        }
        
        function restartGameSimple() {
            console.log('🎮 Simple game restart initiated - restarting Level 1');
            
            // Clean up event listeners
            document.removeEventListener('keydown', handleRetryInput);
            document.removeEventListener('click', handleRetryClick);
            
            // Stop any game loops
            if (forestGame.animationId) {
                cancelAnimationFrame(forestGame.animationId);
                forestGame.animationId = null;
            }
            forestGame.running = false;
            
            // Reset game state but keep selected character
            gameState.lives = 3;
            gameState.score = 0;
            
            // Go to Level 1 starting page (intro screen)
            showLoading('Returning to Level 1 Starting Page...');
            setTimeout(() => {
                transitionToScreen('level1Intro', 'Loading Level 1 Introduction...');
            }, 1500);
        }
        
        function handleRetryClickOLD(event) {
            event.preventDefault();
            event.stopPropagation();
            
            console.log('🖱️ Click detected on retry screen');
            
            if (!forestGame.retryButtons) {
                console.log('❌ No retry buttons found');
                return;
            }
            
            if (!forestGame.canvas) {
                console.log('❌ No canvas found');
                return;
            }
            
            const rect = forestGame.canvas.getBoundingClientRect();
            // Ensure proper scaling calculation
            const scaleX = forestGame.canvas.width / rect.width;
            const scaleY = forestGame.canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            
            console.log(`🎯 Click at canvas coords: (${Math.round(x)}, ${Math.round(y)})`);
            console.log(`📏 Canvas scale: ${scaleX.toFixed(2)}x${scaleY.toFixed(2)}`);
            
            const retryBtn = forestGame.retryButtons.retry;
            const titleBtn = forestGame.retryButtons.title;
            
            console.log(`🔄 Retry button bounds: (${retryBtn.x}, ${retryBtn.y}) ${retryBtn.width}x${retryBtn.height}`);
            console.log(`🏠 Title button bounds: (${titleBtn.x}, ${titleBtn.y}) ${titleBtn.width}x${titleBtn.height}`);
            
            // Add some padding to make buttons easier to click
            const padding = 10;
            
            if (x >= retryBtn.x - padding && x <= retryBtn.x + retryBtn.width + padding &&
                y >= retryBtn.y - padding && y <= retryBtn.y + retryBtn.height + padding) {
                console.log('✅ Retry button clicked!');
                cleanupRetryListeners();
                restartGame();
            } else if (x >= titleBtn.x - padding && x <= titleBtn.x + titleBtn.width + padding &&
                       y >= titleBtn.y - padding && y <= titleBtn.y + titleBtn.height + padding) {
                console.log('✅ Title button clicked!');
                cleanupRetryListeners();
                // Stop the game loop before transitioning
                forestGame.running = false;
                if (forestGame.animationId) {
                    cancelAnimationFrame(forestGame.animationId);
                    forestGame.animationId = null;
                }
                transitionToScreen('title', 'Returning to Title...');
            } else {
                console.log(`❌ Click missed both buttons`);
                console.log(`   Retry test: ${x >= retryBtn.x - padding && x <= retryBtn.x + retryBtn.width + padding && y >= retryBtn.y - padding && y <= retryBtn.y + retryBtn.height + padding}`);
                console.log(`   Title test: ${x >= titleBtn.x - padding && x <= titleBtn.x + titleBtn.width + padding && y >= titleBtn.y - padding && y <= titleBtn.y + titleBtn.height + padding}`);
            }
        }
        
        function cleanupRetryListeners() {
            document.removeEventListener('keydown', handleRetryInput);
            document.removeEventListener('click', handleRetryClick);
            forestGame.retryButtons = null;
        }
        
        function handleRetryInput(event) {
            console.log('⌨️ KEY PRESSED:', event.key);
            
            if (event.key.toLowerCase() === 'r') {
                console.log('🔄 R key pressed - RESTARTING GAME');
                restartGameSimple();
            } else if (event.key.toLowerCase() === 't') {
                console.log('🏠 T key pressed - GOING TO TITLE');
                window.location.href = 'index.html'; // Simple title return
            } else if (event.key === 'Escape') {
                console.log('🚪 ESC key pressed - QUITTING');
                alert('Thanks for playing Guardians of Azureon!');
                alert('Thanks for playing Guardians of Azureon!');
            }
        }
        
        function showLevelCompleteScreen() {
            console.log('🎉 Showing Level Complete Screen');
            
            // Completely stop the game
            forestGame.running = false;
            if (forestGame.animationId) {
                cancelAnimationFrame(forestGame.animationId);
                forestGame.animationId = null;
            }
            
            const canvas = forestGame.canvas;
            const ctx = forestGame.ctx;
            
            // Pre-calculate victory stars for better performance
            let victoryStars = [];
            if (victoryStars.length === 0) {
                for (let i = 0; i < 120; i++) {
                    victoryStars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        brightness: Math.random(),
                        speed: 0.3 + Math.random() * 0.7,
                        isGold: Math.random() > 0.7
                    });
                }
            }
            
            function renderLevelCompleteScreen() {
                // Enhanced victory gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#0d1b2a');
                gradient.addColorStop(0.3, '#1b263b');
                gradient.addColorStop(0.7, '#415a77');
                gradient.addColorStop(1, '#778da9');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Optimized victory stars
                const time = Date.now() * 0.001;
                victoryStars.forEach(star => {
                    const twinkle = Math.sin(time * star.speed + star.brightness * 8) * 0.4 + 0.6;
                    const color = star.isGold ? `rgba(255, 215, 0, ${twinkle})` : `rgba(255, 255, 255, ${twinkle * 0.8})`;
                    ctx.fillStyle = color;
                    ctx.fillRect(star.x, star.y, star.isGold ? 4 : 3, star.isGold ? 4 : 3);
                });
                
                // Victory celebration banner
                const bannerY = 60;
                const bannerHeight = 100;
                
                // Banner background
                ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.fillRect(0, bannerY, canvas.width, bannerHeight);
                
                // Banner borders
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 4;
                ctx.strokeRect(0, bannerY, canvas.width, bannerHeight);
                
                // Victory Title with enhanced effects
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 56px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#FF6B35';
                ctx.shadowBlur = 25;
                
                // Multiple shadow layers for depth
                ctx.strokeStyle = '#FF8A50';
                ctx.lineWidth = 3;
                ctx.strokeText('🎉 LEVEL 1 COMPLETE! 🎉', canvas.width / 2, bannerY + 60);
                ctx.fillText('� LEVEL 1 COMPLETE! �', canvas.width / 2, bannerY + 60);
                
                // Player achievement card
                const cardY = 180;
                const cardHeight = 140;
                const cardX = canvas.width / 6;
                const cardWidth = (canvas.width * 2) / 3;
                
                // Card background with gradient
                const cardGradient = ctx.createLinearGradient(cardX, cardY, cardX, cardY + cardHeight);
                cardGradient.addColorStop(0, 'rgba(25, 118, 210, 0.9)');
                cardGradient.addColorStop(1, 'rgba(13, 71, 161, 0.9)');
                ctx.fillStyle = cardGradient;
                ctx.fillRect(cardX, cardY, cardWidth, cardHeight);
                
                // Card border with glow
                ctx.strokeStyle = '#64B5F6';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#2196F3';
                ctx.shadowBlur = 15;
                ctx.strokeRect(cardX, cardY, cardWidth, cardHeight);
                ctx.shadowBlur = 0;
                
                // Player name and congratulations
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 32px Arial';
                ctx.fillText(`🏅 Congratulations, ${gameState.playerName}! 🏅`, canvas.width / 2, cardY + 40);
                
                // Score displays with icons
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'bold 26px Arial';
                ctx.fillText(`🎯 Total Points: ${gameState.score.toLocaleString()}`, canvas.width / 2, cardY + 80);
                
                const kingdomScore = Math.floor(gameState.score * 1.5);
                ctx.fillStyle = '#9C27B0';
                ctx.fillText(`👑 Kingdom Points: ${kingdomScore.toLocaleString()}`, canvas.width / 2, cardY + 115);
                
                // Enhanced button styling with animations
                const buttonWidth = 260;
                const buttonHeight = 65;
                const centerX = canvas.width / 2;
                
                // Retry Level 1 button with gradient and glow
                const retryBtn = { x: centerX - buttonWidth/2, y: 310, width: buttonWidth, height: buttonHeight };
                const retryGradient = ctx.createLinearGradient(retryBtn.x, retryBtn.y, retryBtn.x, retryBtn.y + retryBtn.height);
                retryGradient.addColorStop(0, '#00DD00');
                retryGradient.addColorStop(1, '#007700');
                ctx.fillStyle = retryGradient;
                ctx.fillRect(retryBtn.x, retryBtn.y, retryBtn.width, retryBtn.height);
                
                const retryGlow = Math.sin(time * 2) * 0.3 + 0.8;
                ctx.strokeStyle = `rgba(0, 255, 0, ${retryGlow})`;
                ctx.lineWidth = 6;
                ctx.strokeRect(retryBtn.x - 3, retryBtn.y - 3, retryBtn.width + 6, retryBtn.height + 6);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 26px Arial';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 4;
                ctx.fillText('🔄 RETRY LEVEL 1', centerX, retryBtn.y + 40);
                
                // Go to Level 2 button with gradient and glow
                const level2Btn = { x: centerX - buttonWidth/2, y: 390, width: buttonWidth, height: buttonHeight };
                const level2Gradient = ctx.createLinearGradient(level2Btn.x, level2Btn.y, level2Btn.x, level2Btn.y + level2Btn.height);
                level2Gradient.addColorStop(0, '#FF8800');
                level2Gradient.addColorStop(1, '#CC4400');
                ctx.fillStyle = level2Gradient;
                ctx.fillRect(level2Btn.x, level2Btn.y, level2Btn.width, level2Btn.height);
                
                const level2Glow = Math.sin(time * 2 + 1) * 0.3 + 0.8;
                ctx.strokeStyle = `rgba(255, 165, 0, ${level2Glow})`;
                ctx.lineWidth = 6;
                ctx.strokeRect(level2Btn.x - 3, level2Btn.y - 3, level2Btn.width + 6, level2Btn.height + 6);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 4;
                ctx.fillText('🚀 GO TO LEVEL 2', centerX, level2Btn.y + 40);
                
                // Title Screen button with gradient and glow
                const titleBtn = { x: centerX - buttonWidth/2, y: 470, width: buttonWidth, height: buttonHeight };
                const titleGradient = ctx.createLinearGradient(titleBtn.x, titleBtn.y, titleBtn.x, titleBtn.y + titleBtn.height);
                titleGradient.addColorStop(0, '#AA66CC');
                titleGradient.addColorStop(1, '#663399');
                ctx.fillStyle = titleGradient;
                ctx.fillRect(titleBtn.x, titleBtn.y, titleBtn.width, titleBtn.height);
                
                const titleGlow = Math.sin(time * 2 + 2) * 0.3 + 0.8;
                ctx.strokeStyle = `rgba(170, 102, 204, ${titleGlow})`;
                ctx.lineWidth = 6;
                ctx.strokeRect(titleBtn.x - 3, titleBtn.y - 3, titleBtn.width + 6, titleBtn.height + 6);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 4;
                ctx.fillText('🏠 TITLE SCREEN', centerX, titleBtn.y + 40);
                ctx.shadowBlur = 0;
                
                // Keyboard instructions
                ctx.fillStyle = '#CCCCCC';
                ctx.font = 'bold 18px Arial';
                ctx.fillText('Press 1 (Retry) • 2 (Level 2) • T (Title)', centerX, 570);
                
                // Store button positions for click detection
                forestGame.levelCompleteButtons = { retry: retryBtn, level2: level2Btn, title: titleBtn };
            }
            
            // Start animation loop for level complete screen
            function animateLevelCompleteScreen() {
                renderLevelCompleteScreen();
                if (!forestGame.running) {
                    requestAnimationFrame(animateLevelCompleteScreen);
                }
            }
            
            // Clean up any existing listeners first
            cleanupLevelCompleteListeners();
            
            // Add event listeners
            document.addEventListener('click', handleLevelCompleteClick);
            document.addEventListener('keydown', handleLevelCompleteKeys);
            console.log('🎮 Level Complete event listeners added');
            
            // Start the animation
            animateLevelCompleteScreen();
        }
        
        function cleanupLevelCompleteListeners() {
            document.removeEventListener('click', handleLevelCompleteClick);
            document.removeEventListener('keydown', handleLevelCompleteKeys);
            forestGame.levelCompleteButtons = null;
        }
        
        function handleLevelCompleteClick(event) {
            if (!forestGame.levelCompleteButtons) return;
            
            event.preventDefault();
            event.stopPropagation();
            
            const rect = forestGame.canvas.getBoundingClientRect();
            // Account for canvas scaling
            const x = (event.clientX - rect.left) * (forestGame.canvas.width / rect.width);
            const y = (event.clientY - rect.top) * (forestGame.canvas.height / rect.height);
            
            console.log(`Level Complete click at: (${Math.round(x)}, ${Math.round(y)})`);
            
            const buttons = forestGame.levelCompleteButtons;
            
            if (x >= buttons.retry.x && x <= buttons.retry.x + buttons.retry.width &&
                y >= buttons.retry.y && y <= buttons.retry.y + buttons.retry.height) {
                console.log('✅ Retry button clicked! Going to Level 1 starting page');
                cleanupLevelCompleteListeners();
                
                // Reset basic game state but preserve character and kingdom
                gameState.lives = 3;
                gameState.score = 0;
                gameState.hasKey = false;
                gameState.hasSword = false;
                gameState.hasForestRelic = false;
                gameState.gameOver = false;
                gameState.levelComplete = false;
                
                // Stop any running game loops
                forestGame.running = false;
                if (forestGame.animationId) {
                    cancelAnimationFrame(forestGame.animationId);
                    forestGame.animationId = null;
                }
                
                // Go to Level 1 starting page (intro screen)
                transitionToScreen('level1Intro', 'Returning to Level 1 Starting Page...');
            } else if (x >= buttons.level2.x && x <= buttons.level2.x + buttons.level2.width &&
                       y >= buttons.level2.y && y <= buttons.level2.y + buttons.level2.height) {
                console.log('✅ Level 2 button clicked!');
                cleanupLevelCompleteListeners();
                // Save current game state and transition to Level 2
                const kingdomScore = Math.floor(gameState.score * 1.5);
                localStorage.setItem('azureon_score', gameState.score.toString());
                localStorage.setItem('azureon_lives', gameState.lives.toString());
                localStorage.setItem('azureon_player_name', gameState.playerName);
                localStorage.setItem('azureon_forest_relic', gameState.hasForestRelic.toString());
                localStorage.setItem('kingdomScore', kingdomScore.toString());
                console.log('💾 Saved to localStorage:', {
                    score: gameState.score,
                    lives: gameState.lives,
                    name: gameState.playerName,
                    forestRelic: gameState.hasForestRelic,
                    kingdomScore: kingdomScore
                });
                window.location.href = 'level2.html?from=level1';
            } else if (x >= buttons.title.x && x <= buttons.title.x + buttons.title.width &&
                       y >= buttons.title.y && y <= buttons.title.y + buttons.title.height) {
                console.log('✅ Title button clicked!');
                cleanupLevelCompleteListeners();
                // Stop the game loop before transitioning
                forestGame.running = false;
                if (forestGame.animationId) {
                    cancelAnimationFrame(forestGame.animationId);
                    forestGame.animationId = null;
                }
                transitionToScreen('title', 'Returning to Title...');
            } else {
                console.log(`❌ Click missed all buttons`);
            }
        }
        
        function handleLevelCompleteKeys(event) {
            if (event.key === '1') {
                console.log('🎮 Key "1" pressed! Going to Level 1 starting page');
                cleanupLevelCompleteListeners();
                
                // Reset basic game state but preserve character and kingdom
                gameState.lives = 3;
                gameState.score = 0;
                gameState.hasKey = false;
                gameState.hasSword = false;
                gameState.hasForestRelic = false;
                gameState.gameOver = false;
                gameState.levelComplete = false;
                
                // Stop any running game loops
                forestGame.running = false;
                if (forestGame.animationId) {
                    cancelAnimationFrame(forestGame.animationId);
                    forestGame.animationId = null;
                }
                
                // Go to Level 1 starting page (intro screen)
                transitionToScreen('level1Intro', 'Returning to Level 1 Starting Page...');
            } else if (event.key === '2') {
                cleanupLevelCompleteListeners();
                // Save current game state and transition to Level 2
                localStorage.setItem('azureon_score', gameState.score.toString());
                localStorage.setItem('azureon_lives', gameState.lives.toString());
                localStorage.setItem('azureon_player_name', gameState.playerName);
                localStorage.setItem('azureon_forest_relic', gameState.hasForestRelic.toString());
                console.log('💾 Saved to localStorage:', {
                    score: gameState.score,
                    lives: gameState.lives,
                    name: gameState.playerName,
                    forestRelic: gameState.hasForestRelic
                });
                window.location.href = 'level2.html?from=level1';
            } else if (event.key.toLowerCase() === 't') {
                cleanupLevelCompleteListeners();
                // Stop the game loop before transitioning
                forestGame.running = false;
                if (forestGame.animationId) {
                    cancelAnimationFrame(forestGame.animationId);
                    forestGame.animationId = null;
                }
                transitionToScreen('title', 'Returning to Title...');
            }
        }
        
        function cleanupLevelCompleteListeners() {
            document.removeEventListener('click', handleLevelCompleteClick);
            document.removeEventListener('keydown', handleLevelCompleteKeys);
            forestGame.levelCompleteButtons = null;
        }
        
        function restartGame() {
            console.log('Restarting game - resetting all state');
            
            // Ensure no conflicting event listeners
            cleanupRetryListeners();
            cleanupLevelCompleteListeners();
            
            // Preserve Kingdom score during retry
            const currentKingdomScore = localStorage.getItem('kingdomScore') || '0';
            console.log('Preserving Kingdom score during retry:', currentKingdomScore);
            
            // Reset all game state but preserve Kingdom score
            gameState.lives = 3;
            gameState.score = 0;
            gameState.hasKey = false;
            gameState.hasSword = false;
            gameState.hasForestRelic = false;
            gameState.gameOver = false;
            gameState.levelComplete = false;
            gameState.currentScreen = 'game';
            
            // Update UI elements
            updateLifeDisplay();
            updateScoreDisplay();
            updateGameHUD();
            
            // Ensure Kingdom score is preserved
            localStorage.setItem('kingdomScore', currentKingdomScore);
            localStorage.setItem('azureon_score', '0'); // Reset stored score
            
            // Reset forest game state completely
            forestGame.player = {
                x: 100,
                y: 400,
                width: 30,
                height: 30,
                velocityX: 0,
                velocityY: 0,
                onGround: false,
                invulnerable: false,
                invulnerabilityTimer: 0
            };
            forestGame.currentPage = 1;
            forestGame.camera = { x: 0 };
            forestGame.swordFound = false;
            forestGame.swordCooldown = 0;
            forestGame.scorePopups = [];
            
            // Reset enemy persistence completely
            forestGame.enemyPersistence = {
                birds: [],
                boss: null,
                birdsSpawned: false,
                bossSpawned: false
            };
            forestGame.enemies = [];
            forestGame.enemiesSpawned = false;
            forestGame.bossSpawned = false;
            forestGame.levelComplete = false;
            
            // Reset game flags
            gameState.hasForestRelic = false;
            forestGame.swordFound = false;
            
            // Clear all game objects
            forestGame.collectibles = [];
            forestGame.particles = [];
            forestGame.keys = {}; // Clear key states
            
            // Cancel any existing animation frame
            if (forestGame.animationId) {
                cancelAnimationFrame(forestGame.animationId);
                forestGame.animationId = null;
            }
            
            // Clear the current screen state
            gameState.currentScreen = 'game';
            gameState.gameOver = false;
            gameState.levelComplete = false;
            
            // Show the game screen and hide others
            showScreen('game');
            
            // Reinitialize the forest game with clean state
            initializeForestGame();
            
            // Ensure all level elements are created (all pages)
            createMarshlandsElements(); // Page 2 with sword
            createCombatArenaElements(); // Page 3 with combat arena
            
            // Set the game as running and start the loop
            forestGame.running = true;
            console.log('Game restarted - beginning new game loop with all level elements');
            forestGameLoop();
        }

        function renderForestGame() {
            const ctx = forestGame.ctx;
            const canvas = forestGame.canvas;
            
            // Clear canvas with sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB'); // Sky blue
            gradient.addColorStop(0.7, '#98FB98'); // Light green
            gradient.addColorStop(1, '#228B22'); // Forest green
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Save context for camera translation
            ctx.save();
            ctx.translate(-forestGame.camera.x, 0);
            
            // TEST: Draw a simple red square to verify rendering is working
            ctx.fillStyle = 'red';
            ctx.fillRect(50, 50, 100, 100);
            
            // Render background elements
            renderClouds(ctx);
            renderTrees(ctx);
            renderPlatforms(ctx);
            renderMovingPlatforms(ctx);
            renderMarshes(ctx);
            renderCrumblingTiles(ctx);
            renderObstacles(ctx);
            renderEnemies(ctx);
            renderCollectibles(ctx);
            renderPlayer(ctx);
            renderParticles(ctx);
            renderScorePopups(ctx);
            
            // Restore context
            ctx.restore();
        }

        function renderClouds(ctx) {
            forestGame.clouds.forEach(cloud => {
                if (cloud.type === 'dark') {
                    // Dark clouds for page 3
                    ctx.fillStyle = 'rgba(64, 64, 64, 0.7)';
                } else if (cloud.type === 'storm') {
                    // Storm clouds for page 3
                    ctx.fillStyle = 'rgba(32, 32, 32, 0.8)';
                } else {
                    // Normal clouds
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                }
                
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.width/2, cloud.height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cloud.x + cloud.width/3, cloud.y, cloud.width/3, cloud.height/3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cloud.x - cloud.width/3, cloud.y, cloud.width/3, cloud.height/3, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function renderTrees(ctx) {
            forestGame.trees.forEach(tree => {
                // Tree trunk
                if (tree.type === 'dead') {
                    ctx.fillStyle = '#4A4A4A'; // Gray dead trunk
                } else if (tree.type === 'marsh') {
                    ctx.fillStyle = '#6B4423'; // Dark marsh trunk
                } else if (tree.type === 'dark') {
                    ctx.fillStyle = '#2F2F2F'; // Very dark trunk for page 3
                } else {
                    ctx.fillStyle = '#8B4513'; // Normal brown trunk
                }
                
                const trunkWidth = (tree.type === 'dark' || tree.type === 'dead') ? 20 : 30;
                ctx.fillRect(tree.x - trunkWidth/2, tree.y, trunkWidth, tree.height);
                
                // Tree leaves/canopy
                if (tree.type === 'dead') {
                    // Dead tree - no leaves, just bare branches
                    ctx.strokeStyle = '#696969';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(tree.x, tree.y);
                    ctx.lineTo(tree.x - 25, tree.y - 35);
                    ctx.moveTo(tree.x, tree.y);
                    ctx.lineTo(tree.x + 25, tree.y - 35);
                    ctx.moveTo(tree.x, tree.y - 15);
                    ctx.lineTo(tree.x - 15, tree.y - 25);
                    ctx.moveTo(tree.x, tree.y - 15);
                    ctx.lineTo(tree.x + 15, tree.y - 25);
                    ctx.stroke();
                } else if (tree.type === 'dark') {
                    // Dark trees for page 3 - ominous black-green leaves
                    ctx.fillStyle = '#0F2F0F';
                    ctx.beginPath();
                    ctx.ellipse(tree.x, tree.y - 25, 40, 70, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add dark highlights
                    ctx.fillStyle = '#1F4F1F';
                    ctx.beginPath();
                    ctx.ellipse(tree.x, tree.y - 20, 35, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (tree.type === 'marsh') {
                    // Marsh tree - darker, sparser leaves
                    ctx.fillStyle = '#2F4F2F';
                    ctx.beginPath();
                    ctx.ellipse(tree.x, tree.y - 20, 50, 60, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Normal forest trees
                    ctx.fillStyle = tree.type === 'tall' ? '#228B22' : '#32CD32';
                    ctx.beginPath();
                    ctx.ellipse(tree.x, tree.y - 20, 60, 80, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function renderPlatforms(ctx) {
            forestGame.platforms.forEach(platform => {
                if (platform.type === 'rope') {
                    // Render green rope
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    // Add rope texture with segments
                    ctx.fillStyle = '#32CD32';
                    for (let y = platform.y; y < platform.y + platform.height; y += 20) {
                        ctx.fillRect(platform.x, y, platform.width, 2);
                    }
                } else if (platform.type === 'stone') {
                    // Stone platforms for marshlands
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    // Add stone texture
                    ctx.fillStyle = '#556B2F';
                    ctx.fillRect(platform.x, platform.y, platform.width, 5);
                } else if (platform.type === 'floating_stone') {
                    // Floating stone platforms
                    ctx.fillStyle = '#778899';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    ctx.fillStyle = '#2F4F4F';
                    ctx.fillRect(platform.x, platform.y, platform.width, 3);
                } else if (platform.type === 'arena_ground') {
                    // Combat arena ground - darker, more ominous
                    ctx.fillStyle = '#2F2F2F';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    // Add some texture
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect(platform.x, platform.y, platform.width, 8);
                } else if (platform.type === 'battle_platform') {
                    // Battle platforms - metallic appearance
                    ctx.fillStyle = '#4682B4';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    // Add metallic shine
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(platform.x, platform.y, platform.width, 3);
                } else if (platform.type === 'bridge') {
                    // Bridge platforms for transitions
                    ctx.fillStyle = '#D2691E'; // Saddle brown
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    // Add wooden planks texture
                    ctx.fillStyle = '#CD853F';
                    for (let i = 0; i < platform.width; i += 15) {
                        ctx.fillRect(platform.x + i, platform.y + 2, 12, platform.height - 4);
                    }
                    
                    // Add rope details
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(platform.x, platform.y - 2, platform.width, 2);
                    ctx.fillRect(platform.x, platform.y + platform.height, platform.width, 2);
                } else if (platform.type === 'ground') {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    // Add some texture
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(platform.x, platform.y, platform.width, 5);
                } else {
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    // Add some texture
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(platform.x, platform.y, platform.width, 5);
                }
            });
        }

        function renderObstacles(ctx) {
            forestGame.obstacles.forEach(obstacle => {
                const pulse = Math.sin(obstacle.animFrame) * 0.1 + 1;
                
                ctx.save();
                ctx.scale(pulse, pulse);
                
                if (obstacle.type === 'iron_spike') {
                    ctx.fillStyle = '#708090'; // Steel blue
                    ctx.shadowColor = '#708090';
                    ctx.shadowBlur = 8;
                    drawSpike(ctx, obstacle.x / pulse, obstacle.y / pulse, obstacle.width, obstacle.height);
                    
                    // Metallic shine
                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillRect((obstacle.x + 2) / pulse, (obstacle.y + 2) / pulse, 3, obstacle.height - 4);
                    
                } else if (obstacle.type === 'poison_spike') {
                    ctx.fillStyle = '#9ACD32'; // Green
                    ctx.shadowColor = '#32CD32';
                    ctx.shadowBlur = 12;
                    drawSpike(ctx, obstacle.x / pulse, obstacle.y / pulse, obstacle.width, obstacle.height);
                    
                    // Poison drip effect
                    ctx.fillStyle = '#00FF00';
                    const drip = Math.sin(obstacle.animFrame * 2) * 3;
                    ctx.fillRect((obstacle.x + obstacle.width/2 - 1) / pulse, (obstacle.y + obstacle.height + drip) / pulse, 2, 4);
                    
                } else if (obstacle.type === 'fire_spike') {
                    ctx.fillStyle = '#FF4500'; // Orange red
                    ctx.shadowColor = '#FF6347';
                    ctx.shadowBlur = 15;
                    drawSpike(ctx, obstacle.x / pulse, obstacle.y / pulse, obstacle.width, obstacle.height);
                    
                    // Fire effect
                    ctx.fillStyle = '#FFD700';
                    const flame = Math.sin(obstacle.animFrame * 3) * 2;
                    ctx.fillRect((obstacle.x + obstacle.width/2 - 2) / pulse, (obstacle.y - 5 + flame) / pulse, 4, 8);
                    
                } else if (obstacle.type === 'crystal_spikes') {
                    ctx.fillStyle = '#DA70D6'; // Orchid
                    ctx.shadowColor = '#DA70D6';
                    ctx.shadowBlur = 20;
                    // Multiple small spikes
                    for (let i = 0; i < 3; i++) {
                        drawSpike(ctx, (obstacle.x + i * 12) / pulse, obstacle.y / pulse, 10, obstacle.height);
                    }
                    
                } else if (obstacle.type === 'thorn_bush') {
                    ctx.fillStyle = '#8B4513'; // Saddle brown
                    ctx.shadowColor = '#8B0000';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(obstacle.x / pulse, obstacle.y / pulse, obstacle.width, obstacle.height);
                    
                    // Thorns
                    ctx.fillStyle = '#654321';
                    for (let i = 0; i < 5; i++) {
                        const thornX = obstacle.x + (i * 8) + Math.sin(obstacle.animFrame + i) * 2;
                        drawSpike(ctx, thornX / pulse, (obstacle.y - 5) / pulse, 6, 8);
                    }
                } else if (obstacle.type === 'shadow_spikes') {
                    // Dark shadow spikes for page 3
                    ctx.fillStyle = '#2F2F2F';
                    ctx.shadowColor = '#8B0000';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(obstacle.x / pulse, obstacle.y / pulse, obstacle.width, obstacle.height);
                    
                    // Add menacing glow
                    ctx.fillStyle = '#8B0000';
                    ctx.fillRect((obstacle.x + 2) / pulse, obstacle.y / pulse, (obstacle.width - 4), 4);
                } else if (obstacle.type === 'dark_crystal') {
                    // Dark crystals for page 3
                    const darkColors = ['#4B0082', '#2F4F4F', '#191970', '#000080'];
                    ctx.fillStyle = darkColors[Math.floor(obstacle.animFrame) % 4];
                    ctx.shadowColor = '#4B0082';
                    ctx.shadowBlur = 20;
                    ctx.fillRect(obstacle.x / pulse, obstacle.y / pulse, obstacle.width, obstacle.height);
                    
                    // Add dark sparkles
                    ctx.fillStyle = '#483D8B';
                    ctx.fillRect((obstacle.x + 8) / pulse, (obstacle.y + 3) / pulse, 3, 3);
                    ctx.fillRect((obstacle.x + 20) / pulse, (obstacle.y + 10) / pulse, 2, 2);
                } else if (obstacle.type === 'void_trap') {
                    // Void traps for page 3
                    ctx.fillStyle = '#000000';
                    ctx.shadowColor = '#4B0082';
                    ctx.shadowBlur = 25;
                    ctx.fillRect(obstacle.x / pulse, obstacle.y / pulse, obstacle.width, obstacle.height);
                    
                    // Add swirling void effect
                    ctx.fillStyle = '#4B0082';
                    const swirl = Math.sin(obstacle.animFrame * 0.5) * 5;
                    ctx.fillRect((obstacle.x + 10 + swirl) / pulse, (obstacle.y + 5) / pulse, 6, 6);
                    ctx.fillRect((obstacle.x + 20 - swirl) / pulse, (obstacle.y + 10) / pulse, 4, 4);
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }
        
        function drawSpike(ctx, x, y, width, height) {
            ctx.beginPath();
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + width/2, y);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.fill();
        }

        function renderCollectibles(ctx) {
            const time = Date.now() * 0.005;
            
            forestGame.collectibles.forEach(collectible => {
                if (collectible.collected) return;
                
                const bobOffset = Math.sin(time + collectible.x * 0.01) * 4;
                const pulse = Math.sin(time * 2) * 0.1 + 1;
                const x = collectible.x;
                const y = collectible.y + bobOffset;
                
                ctx.save();
                ctx.scale(pulse, pulse);
                
                if (collectible.type === 'gold_coin') {
                    ctx.fillStyle = collectible.color;
                    ctx.shadowColor = collectible.color;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc((x + 15) / pulse, (y + 15) / pulse, 12, 0, Math.PI * 2);
                    ctx.fill();
                    // Inner circle
                    ctx.fillStyle = '#FFF8DC';
                    ctx.beginPath();
                    ctx.arc((x + 15) / pulse, (y + 15) / pulse, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else if (collectible.type === 'silver_coin') {
                    ctx.fillStyle = collectible.color;
                    ctx.shadowColor = collectible.color;
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc((x + 15) / pulse, (y + 15) / pulse, 10, 0, Math.PI * 2);
                    ctx.fill();
                } else if (collectible.type === 'emerald') {
                    ctx.fillStyle = collectible.color;
                    ctx.shadowColor = collectible.color;
                    ctx.shadowBlur = 20;
                    // Diamond shape
                    ctx.beginPath();
                    ctx.moveTo((x + 15) / pulse, (y + 5) / pulse);
                    ctx.lineTo((x + 25) / pulse, (y + 15) / pulse);
                    ctx.lineTo((x + 15) / pulse, (y + 25) / pulse);
                    ctx.lineTo((x + 5) / pulse, (y + 15) / pulse);
                    ctx.closePath();
                    ctx.fill();
                } else if (collectible.type === 'ruby') {
                    ctx.fillStyle = collectible.color;
                    ctx.shadowColor = collectible.color;
                    ctx.shadowBlur = 25;
                    // Star shape
                    drawStar(ctx, (x + 15) / pulse, (y + 15) / pulse, 5, 12, 6);
                } else if (collectible.type === 'treasure_chest') {
                    ctx.fillStyle = collectible.color;
                    ctx.shadowColor = collectible.color;
                    ctx.shadowBlur = 30;
                    ctx.fillRect((x + 2) / pulse, (y + 10) / pulse, 26, 20);
                    // Chest lock
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect((x + 12) / pulse, (y + 15) / pulse, 6, 8);
                } else if (collectible.type === 'health_potion') {
                    ctx.fillStyle = collectible.color;
                    ctx.shadowColor = collectible.color;
                    ctx.shadowBlur = 18;
                    // Potion bottle
                    ctx.fillRect((x + 8) / pulse, (y + 8) / pulse, 14, 20);
                    ctx.fillStyle = '#FF69B4';
                    ctx.fillRect((x + 10) / pulse, (y + 10) / pulse, 10, 16);
                    // Plus sign
                    ctx.fillStyle = '#FFF';
                    ctx.fillRect((x + 13) / pulse, (y + 12) / pulse, 4, 2);
                    ctx.fillRect((x + 14) / pulse, (y + 11) / pulse, 2, 4);
                } else if (collectible.type === 'speed_boost') {
                    ctx.fillStyle = collectible.color;
                    ctx.shadowColor = collectible.color;
                    ctx.shadowBlur = 22;
                    // Lightning bolt shape
                    ctx.beginPath();
                    ctx.moveTo((x + 15) / pulse, (y + 5) / pulse);
                    ctx.lineTo((x + 10) / pulse, (y + 15) / pulse);
                    ctx.lineTo((x + 20) / pulse, (y + 15) / pulse);
                    ctx.lineTo((x + 15) / pulse, (y + 25) / pulse);
                    ctx.lineTo((x + 20) / pulse, (y + 15) / pulse);
                    ctx.lineTo((x + 10) / pulse, (y + 15) / pulse);
                    ctx.closePath();
                    ctx.fill();
                } else if (collectible.type === 'sword_of_azureon') {
                    // Legendary Sword of Azureon with epic glow
                    ctx.fillStyle = collectible.color;
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 40;
                    
                    // Sword blade
                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillRect((x + 18) / pulse, (y + 5) / pulse, 4, 25);
                    
                    // Sword hilt
                    ctx.fillStyle = '#B8860B';
                    ctx.fillRect((x + 15) / pulse, (y + 30) / pulse, 10, 8);
                    
                    // Cross guard
                    ctx.fillStyle = '#DAA520';
                    ctx.fillRect((x + 8) / pulse, (y + 28) / pulse, 24, 4);
                    
                    // Glowing aura effect
                    const auraIntensity = Math.sin(time * 3) * 0.5 + 1;
                    ctx.fillStyle = `rgba(255, 215, 0, ${0.3 * auraIntensity})`;
                    ctx.fillRect((x - 5) / pulse, (y - 5) / pulse, 50, 50);
                } else if (collectible.type === 'forest_relic') {
                    // Enhanced Forest Relic with magical glow
                    const glowIntensity = Math.sin(time * 4) * 0.4 + 0.8;
                    ctx.shadowColor = '#00FF7F';
                    ctx.shadowBlur = 30 * glowIntensity;
                    
                    // Outer magical glow
                    ctx.fillStyle = `rgba(0, 255, 127, ${0.3 * glowIntensity})`;
                    ctx.fillRect((x - 10) / pulse, (y - 10) / pulse, 70, 70);
                    
                    // Main relic body (crystalline)
                    ctx.fillStyle = '#32CD32';
                    ctx.fillRect((x + 5) / pulse, (y + 5) / pulse, 40, 40);
                    
                    // Inner crystal core
                    ctx.fillStyle = '#00FF7F';
                    ctx.fillRect((x + 15) / pulse, (y + 15) / pulse, 20, 20);
                    
                    // Sparkles around relic
                    for (let i = 0; i < 6; i++) {
                        const sparkleAngle = (time * 2 + i * Math.PI / 3) % (Math.PI * 2);
                        const sparkleRadius = 30 + Math.sin(time * 3) * 5;
                        const sparkleX = x + 25 + Math.cos(sparkleAngle) * sparkleRadius;
                        const sparkleY = y + 25 + Math.sin(sparkleAngle) * sparkleRadius;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(sparkleX / pulse, sparkleY / pulse, 3, 3);
                    }
                } else if (collectible.type === 'forest_exit') {
                    // Magical portal exit with swirling effects
                    const portalPulse = Math.sin(time * 2) * 0.3 + 1;
                    ctx.shadowColor = '#9370DB';
                    ctx.shadowBlur = 25 * portalPulse;
                    
                    // Portal outer ring
                    ctx.fillStyle = `rgba(147, 112, 219, ${0.8 * portalPulse})`;
                    ctx.fillRect((x - 5) / pulse, (y - 5) / pulse, 80, 130);
                    
                    // Portal main body
                    ctx.fillStyle = '#4B0082';
                    ctx.fillRect(x / pulse, y / pulse, 70, 120);
                    
                    // Swirling energy inside portal
                    for (let i = 0; i < 8; i++) {
                        const swirlAngle = (time * 3 + i * Math.PI / 4) % (Math.PI * 2);
                        const swirlRadius = 20 + Math.sin(time * 2 + i) * 8;
                        const swirlX = x + 35 + Math.cos(swirlAngle) * swirlRadius;
                        const swirlY = y + 60 + Math.sin(swirlAngle) * swirlRadius * 0.6;
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.7 - i * 0.08})`;
                        ctx.fillRect(swirlX / pulse, swirlY / pulse, 4, 4);
                    }
                    
                    // Portal text
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('EXIT', (x + 35) / pulse, (y + 65) / pulse);
                    ctx.textAlign = 'left';
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }
        
        function drawStar(ctx, x, y, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let step = Math.PI / spikes;
            
            ctx.beginPath();
            ctx.moveTo(x, y - outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
                rot += step;
                ctx.lineTo(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
                rot += step;
            }
            
            ctx.lineTo(x, y - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        function renderPlayer(ctx) {
            const player = forestGame.player;
            const x = player.x;
            const y = player.y;
            const frame = Math.floor(player.animFrame);
            
            // Apply invulnerability flashing
            if (player.invulnerable && Math.floor(Date.now() / 100) % 2) {
                ctx.globalAlpha = 0.5;
            }
            
            // Warrior body with animation
            let bodyOffset = 0;
            if (player.state === 'running') {
                bodyOffset = Math.sin(frame * 0.5) * 2;
            } else if (player.state === 'climbing') {
                bodyOffset = Math.sin(frame * 0.4) * 1; // Subtle climbing motion
            }
            
            // Armor (main body)
            ctx.fillStyle = player.baseColor;
            ctx.fillRect(x + 8, y + 15 + bodyOffset, 24, 30);
            
            // Armor details
            ctx.fillStyle = player.armorColor;
            ctx.fillRect(x + 10, y + 17 + bodyOffset, 20, 5);
            ctx.fillRect(x + 12, y + 25 + bodyOffset, 16, 3);
            ctx.fillRect(x + 14, y + 35 + bodyOffset, 12, 3);
            
            // Head
            ctx.fillStyle = '#FFE4B5';
            ctx.fillRect(x + 12, y + 5, 16, 12);
            
            // Helmet
            ctx.fillStyle = player.armorColor;
            ctx.fillRect(x + 10, y + 3, 20, 8);
            
            // Eyes
            ctx.fillStyle = '#000';
            if (player.direction > 0) {
                ctx.fillRect(x + 20, y + 8, 2, 2);
                ctx.fillRect(x + 24, y + 8, 2, 2);
            } else {
                ctx.fillRect(x + 14, y + 8, 2, 2);
                ctx.fillRect(x + 18, y + 8, 2, 2);
            }
            
            // Legs with running animation
            const legOffset1 = player.state === 'running' ? Math.sin(frame * 0.8) * 3 : 0;
            const legOffset2 = player.state === 'running' ? Math.sin(frame * 0.8 + Math.PI) * 3 : 0;
            
            ctx.fillStyle = player.baseColor;
            ctx.fillRect(x + 12, y + 45 + legOffset1, 6, 8);
            ctx.fillRect(x + 22, y + 45 + legOffset2, 6, 8);
            
            // Arms with animation
            const armOffset = player.state === 'running' ? Math.sin(frame * 0.6) * 2 : 0;
            ctx.fillRect(x + 5, y + 20 + armOffset, 6, 15);
            ctx.fillRect(x + 29, y + 20 - armOffset, 6, 15);
            
            // Draw sword if found
            if (forestGame.swordFound) {
                const swordX = player.direction > 0 ? x + 35 : x + 2;
                const swordY = y + 10;
                
                if (player.attacking) {
                    // Attacking position - sword extended
                    ctx.fillStyle = '#FFD700'; // Golden blade
                    if (player.direction > 0) {
                        ctx.fillRect(swordX + 10, swordY, 3, 25);
                    } else {
                        ctx.fillRect(swordX - 25, swordY, 3, 25);
                    }
                    
                    // Sword glow effect when attacking
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    if (player.direction > 0) {
                        ctx.fillRect(swordX + 8, swordY - 2, 7, 29);
                    } else {
                        ctx.fillRect(swordX - 27, swordY - 2, 7, 29);
                    }
                    
                    // Handle (extended)
                    ctx.fillStyle = '#8B4513';
                    if (player.direction > 0) {
                        ctx.fillRect(swordX + 8, swordY + 25, 7, 8);
                    } else {
                        ctx.fillRect(swordX - 18, swordY + 25, 7, 8);
                    }
                } else {
                    // Resting position - sword at side
                    ctx.fillStyle = '#FFD700'; // Golden blade
                    ctx.fillRect(swordX, swordY + 5, 3, 20);
                    
                    // Handle
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(swordX - 1, swordY + 25, 5, 6);
                }
            } else {
                // Basic weapon (before sword is found)
                ctx.fillStyle = player.weaponColor;
                if (player.direction > 0) {
                    ctx.fillRect(x + 35, y + 18, 3, 12);
                    ctx.fillRect(x + 34, y + 15, 5, 3); // Hilt
                } else {
                    ctx.fillRect(x + 2, y + 18, 3, 12);
                    ctx.fillRect(x + 1, y + 15, 5, 3); // Hilt
                }
            }
            
            // Cape flowing in wind
            if (player.state === 'running' || player.state === 'jumping') {
                ctx.fillStyle = '#8B0000';
                const capeFlow = Math.sin(frame * 0.4) * 3;
                if (player.direction > 0) {
                    ctx.fillRect(x - 5 + capeFlow, y + 18, 8, 20);
                } else {
                    ctx.fillRect(x + 37 - capeFlow, y + 18, 8, 20);
                }
            }
            
            ctx.globalAlpha = 1;
        }

        function renderCrumblingTiles(ctx) {
            forestGame.crumblingTiles.forEach(tile => {
                if (tile.width <= 0) return; // Skip destroyed tiles
                
                const integrityRatio = tile.integrity / tile.maxIntegrity;
                
                // Base tile color changes as it crumbles
                let tileColor = `rgb(${139 + (116 * (1 - integrityRatio))}, ${69 + (31 * (1 - integrityRatio))}, ${19 + (0 * (1 - integrityRatio))})`;
                
                ctx.fillStyle = tileColor;
                ctx.fillRect(tile.x, tile.y, tile.width, tile.height);
                
                // Add cracks as integrity decreases
                if (integrityRatio < 0.8) {
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(tile.x + tile.width * 0.3, tile.y);
                    ctx.lineTo(tile.x + tile.width * 0.3, tile.y + tile.height);
                    ctx.stroke();
                }
                
                if (integrityRatio < 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(tile.x + tile.width * 0.7, tile.y);
                    ctx.lineTo(tile.x + tile.width * 0.7, tile.y + tile.height);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(tile.x, tile.y + tile.height * 0.5);
                    ctx.lineTo(tile.x + tile.width, tile.y + tile.height * 0.5);
                    ctx.stroke();
                }
                
                // Falling debris particles
                if (tile.crumbling) {
                    ctx.fillStyle = '#8B4513';
                    for (let i = 0; i < 5; i++) {
                        const debrisX = tile.x + Math.random() * tile.width;
                        const debrisY = tile.y + tile.height + Math.random() * 20;
                        ctx.fillRect(debrisX, debrisY, 2, 2);
                    }
                }
            });
        }
        
        function renderScorePopups(ctx) {
            ctx.font = '16px Cinzel';
            ctx.textAlign = 'center';
            
            forestGame.scorePopups.forEach(popup => {
                const alpha = popup.life / popup.maxLife;
                ctx.fillStyle = popup.color ? popup.color.replace('rgb', 'rgba').replace(')', `, ${alpha})`) : `rgba(255, 215, 0, ${alpha})`;
                ctx.fillText(popup.value, popup.x + 15, popup.y);
            });
        }

        function renderMovingPlatforms(ctx) {
            forestGame.movingPlatforms.forEach(platform => {
                if (platform.page && platform.page !== forestGame.currentPage) return;
                
                // Moving platform with subtle animation
                const pulse = Math.sin(Date.now() * 0.001) * 0.05 + 1;
                
                ctx.save();
                ctx.scale(pulse, pulse);
                
                // Platform gradient
                const gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
                gradient.addColorStop(0, '#CD853F');
                gradient.addColorStop(1, '#8B4513');
                ctx.fillStyle = gradient;
                ctx.fillRect(platform.x / pulse, platform.y / pulse, platform.width, platform.height);
                
                // Glowing edge effect for moving platforms
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fillRect(platform.x / pulse, platform.y / pulse, platform.width, 2);
                
                ctx.restore();
            });
        }

        function renderMarshes(ctx) {
            forestGame.marshes.forEach(marsh => {
                if (marsh.page && marsh.page !== forestGame.currentPage) return;
                
                // Marsh water with ripple effect
                const time = Date.now() * 0.002;
                const ripple = Math.sin(time + marsh.x * 0.01) * 5;
                
                ctx.fillStyle = 'rgba(34, 139, 34, 0.7)';
                ctx.fillRect(marsh.x, marsh.y + ripple, marsh.width, marsh.height);
                
                // Bubbles
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                for (let i = 0; i < 3; i++) {
                    const bubbleX = marsh.x + (i * marsh.width / 3) + Math.sin(time + i) * 10;
                    const bubbleY = marsh.y + Math.cos(time * 1.5 + i) * 5;
                    ctx.beginPath();
                    ctx.arc(bubbleX, bubbleY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function renderParticles(ctx) {
            forestGame.particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color || '#FFD700';
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                ctx.restore();
            });
        }

        // Global error handling
        window.onerror = function(msg, file, line, col, error) {
            console.error('Game Error:', msg, 'at', file, line);
            return false;
        };
    </script>
</body>
</html>