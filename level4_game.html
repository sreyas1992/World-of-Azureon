<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level 4: Spirit Tree Revival - Guardians of Azureon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3a5f, #2d5aa0, #4a90e2);
            overflow: hidden;
            position: relative;
        }

        /* Water animation background */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0,150,255,0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(100,200,255,0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(0,100,200,0.2) 0%, transparent 50%);
            animation: waterFlow 8s ease-in-out infinite;
            z-index: 1;
        }

        @keyframes waterFlow {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            33% { transform: translateX(-10px) translateY(-5px); }
            66% { transform: translateX(10px) translateY(5px); }
        }

        canvas {
            display: block;
            border: 3px solid #00aaff;
            background: linear-gradient(180deg, #87CEEB 0%, #4682B4 50%, #191970 100%);
            position: relative;
            z-index: 2;
            box-shadow: 0 0 30px rgba(0, 170, 255, 0.5);
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
            z-index: 2;
        }

        /* Score System */
        .score-system {
            position: absolute;
            top: 100px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 90;
            pointer-events: none;
        }

        .player-score-panel, .kingdom-score-panel {
            background: linear-gradient(135deg, rgba(74, 21, 128, 0.9), rgba(30, 41, 59, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 15px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 180px;
            transition: all 0.3s ease;
        }

        .score-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .score-icon {
            font-size: 18px;
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.6));
        }

        .score-title {
            font-family: 'Cinzel', serif;
            font-size: 14px;
            font-weight: 600;
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
        }

        .score-value {
            font-family: 'Cinzel', serif;
            font-size: 28px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            margin-bottom: 4px;
            animation: scoreGlow 2s ease-in-out infinite alternate;
        }

        .score-subtitle {
            font-family: 'Crimson Text', serif;
            font-size: 12px;
            color: #c9aa71;
            text-shadow: 0 0 4px rgba(201, 170, 113, 0.3);
            font-style: italic;
        }

        @keyframes scoreGlow {
            0% {
                text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            }
            100% {
                text-shadow: 0 0 15px rgba(255, 215, 0, 1), 0 0 25px rgba(255, 215, 0, 0.6);
            }
        }

        /* HUD System */
        .hud-overlay {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 20px;
            z-index: 100;
            pointer-events: none;
        }

        .hud-left, .hud-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .hud-center {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .hud-item {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(30, 41, 59, 0.8));
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
        }

        .hud-icon {
            font-size: 16px;
            filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
        }

        .level-title-hud {
            background: linear-gradient(135deg, rgba(74, 21, 128, 0.9), rgba(30, 41, 59, 0.9));
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 20px;
            padding: 12px 25px;
            font-family: 'Cinzel', serif;
            font-size: 18px;
            font-weight: 600;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .lives-display {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .life-counter {
            display: flex;
            gap: 4px;
        }

        .life-heart {
            font-size: 16px;
            filter: drop-shadow(0 0 4px rgba(255, 0, 0, 0.6));
            transition: all 0.3s ease;
        }

        .life-heart.lost {
            opacity: 0.3;
            filter: grayscale(100%);
        }

        .relics-horizontal, .relics-display {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .relic-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .timer-display {
            font-size: 18px;
        }

        .timer-display #timeLeft {
            color: white !important;
            font-weight: bold;
            font-size: 20px;
        }

        .timer {
            color: #ff6b6b;
            font-size: 18px;
            font-weight: bold;
            animation: timerPulse 1s ease-in-out infinite alternate;
        }

        @keyframes timerPulse {
            0% { color: #ff6b6b; }
            100% { color: #ff4444; }
        }



        .message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #00aaff;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 20px;
            font-weight: bold;
            border: 3px solid #00aaff;
            display: none;
            z-index: 15;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 170, 255, 0.6);
        }

        .victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3a5f, #90EE90, #32CD32);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .victory-content {
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #90EE90;
            box-shadow: 0 0 50px rgba(144, 238, 144, 0.8);
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .ending-scene-container {
            margin-bottom: 20px;
        }

        .ending-scene-image {
            max-width: 100%;
            max-height: 300px;
            width: auto;
            height: auto;
            border-radius: 15px;
            border: 2px solid #90EE90;
            box-shadow: 0 0 30px rgba(144, 238, 144, 0.6);
            object-fit: contain;
        }

        .credits-section {
            background: rgba(50, 205, 50, 0.1);
            border: 2px solid #90EE90;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .credits-section h3 {
            color: #90EE90;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(144, 238, 144, 0.8);
        }

        .credits-content {
            font-size: 1.2em;
        }

        .credit-line {
            margin: 8px 0;
            color: #fff;
        }

        .victory-title {
            font-size: 3em;
            margin-bottom: 20px;
            color: #90EE90;
            text-shadow: 0 0 30px rgba(144, 238, 144, 0.8);
            animation: victoryGlow 2s ease-in-out infinite alternate;
        }

        @keyframes victoryGlow {
            0% { text-shadow: 0 0 30px rgba(144, 238, 144, 0.8); }
            100% { text-shadow: 0 0 40px rgba(144, 238, 144, 1); }
        }

        .victory-text {
            font-size: 1.3em;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .final-button {
            background: linear-gradient(135deg, #228B22, #32CD32, #90EE90);
            border: none;
            border-radius: 15px;
            padding: 20px 40px;
            font-size: 1.3em;
            font-weight: 600;
            cursor: pointer;
            color: #fff;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            box-shadow: 0 0 30px rgba(144, 238, 144, 0.6);
            transition: all 0.3s ease;
            margin: 10px;
            text-decoration: none;
            display: inline-block;
        }

        .final-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 40px rgba(144, 238, 144, 0.8);
        }

        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00aaff;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 10;
        }

        /* Particle effects */
        .water-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(135, 206, 235, 0.8);
            border-radius: 50%;
            pointer-events: none;
            animation: waterDrop 3s linear infinite;
        }

        @keyframes waterDrop {
            0% { transform: translateY(-10px); opacity: 1; }
            100% { transform: translateY(100vh); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>
        
        <!-- HUD Overlay -->
        <div class="hud-overlay">
            <div class="hud-left">
                <div class="hud-item timer-display">
                    <span class="hud-icon">⏰</span>
                    <span id="timeLeft" style="color: white; font-weight: bold; font-size: 20px;">60</span>
                </div>
                <div class="hud-item">
                    <span class="hud-icon">�</span>
                    <span id="forestRelic">❌</span>
                </div>

                <div class="hud-item">
                    <span class="hud-icon">�</span>
                    <span id="waterRelic">❌</span>
                </div>
            </div>
            
            <div class="hud-center">
                <div class="level-title-hud">Level 4: Echoes of The Spirit Tree</div>
            </div>
            
            <div class="hud-right">
                <div class="hud-item lives-display">
                    <span class="hud-icon">❤️</span>
                    <div class="life-counter">
                        <div class="life-heart" id="life1">❤️</div>
                        <div class="life-heart" id="life2">❤️</div>
                        <div class="life-heart" id="life3">❤️</div>
                    </div>
                </div>
                <div class="hud-item relics-display">
                    <span class="relic-item">
                        <span class="hud-icon">🌿</span>
                        <span id="forestRelic"></span>
                    </span>
                    <span class="relic-item">
                        <span class="hud-icon">🔥</span>
                        <span id="emberRelic"></span>
                    </span>
                    <span class="relic-item" id="waterRelicContainer" style="display: none;">
                        <span class="hud-icon">💧</span>
                        <span id="waterRelic"></span>
                    </span>
                </div>
            </div>
        </div>
            
        <!-- Score Panels -->
        <div class="score-system">
            <!-- Player Score (Top-Left) -->
            <div class="player-score-panel">
                <div class="score-header">
                    <span class="score-icon">⚔️</span>
                    <span class="score-title">Your Score</span>
                </div>
                <div class="score-value" id="currentScore">0</div>
                <div class="score-subtitle">Guardian Warrior</div>
            </div>
            
            <!-- Kingdom Score (Top-Right) -->
            <div class="kingdom-score-panel">
                <div class="score-header">
                    <span class="score-icon">🌳</span>
                    <span class="score-title">Spirit Tree</span>
                </div>
                <div class="score-value" id="spiritTreeScore">0</div>
                <div class="score-subtitle">Ancient Power</div>
            </div>
        </div>



        <div class="message-overlay" id="messageOverlay">
            Message will appear here
        </div>

        <div class="victory-screen" id="victoryScreen">
            <div class="victory-content">
                <div class="ending-scene-container">
                    <img src="Ending scene.png" alt="Azureon Ending Scene" class="ending-scene-image">
                </div>
                <div class="victory-title">🌳 AZUREON SAVED! 🌳</div>
                <div class="victory-text">
                    The Spirit Tree has been revived! The ancient guardian's light shines once more, 
                    protecting all of Azureon from the forces of darkness. You are the true Guardian!
                </div>
                <div class="victory-text">
                    <strong>Final Score:</strong> <span id="finalScore">0</span><br>
                    <strong>Time Remaining:</strong> <span id="finalTime">0</span> seconds
                </div>
                <div class="credits-section">
                    <h3>Credits</h3>
                    <div class="credits-content">
                        <div class="credit-line"><strong>Game Design:</strong> Sreyas R</div>
                        <div class="credit-line"><strong>Special Mention:</strong></div>
                        <div class="credit-line">Suneet Tangallapally</div>
                        <div class="credit-line">Peter Estibeiro</div>
                    </div>
                </div>
                <a href="index.html" class="final-button">🎮 Play Again</a>
                <a href="level3_complete.html" class="final-button">🏰 Return to Level 3</a>
            </div>
        </div>

        <div class="controls-info">
            WASD/Arrow Keys: Move | Space: Jump | Collect relics and reach the Spirit Tree!
        </div>
    </div>

    <script>
        // ===============================================
        // GAME INITIALIZATION
        // ===============================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        const game = {
            page: 1, // 1 = Water Relic page, 2 = Spirit Tree page
            timeLeft: 90, // 90 seconds
            score: 0,
            lives: 3,
            hasForestRelic: false,
            hasEmberRelic: false,
            hasWaterRelic: false,
            gameComplete: false,
            keys: {},
            camera: { x: 0, y: 0 },
            mapWidth: 2100, // Extended map width for both pages
            mapHeight: 600,
            cinematicMode: false,
            treeGlowing: false,
            treeBranchesGrowing: false,
            treeLeavesAppearing: false,
            treeFullyRevived: false
        };

        // Load previous progress
        function loadGameData() {
            const urlParams = new URLSearchParams(window.location.search);
            
            game.score = parseInt(urlParams.get('playerScore')) || 0;
            game.lives = parseInt(urlParams.get('lives')) || 3;
            game.hasForestRelic = urlParams.get('forestRelic') === 'true';
            game.hasEmberRelic = urlParams.get('emberRelic') === 'true';
            
            // Update HUD
            updateHUD();
        }

        // Player object (exact warrior from Level 1)
        const player = {
            x: 75,
            y: 450,
            width: 30,
            height: 40,
            velocityX: 0,
            velocityY: 0,
            speed: 6,
            jumpPower: 14,
            onGround: false,
            onRope: false,
            color: '#8B4513',
            facingRight: true,
            character: 'warrior' // Warrior type from Level 1
        };

        // Game elements
        const platforms = [];
        const movingPlatforms = [];
        const ropes = [];
        const collectibles = [];
        const waterPits = [];
        const timeBoosts = [];
        const trees = [];
        const coins = [];
        const gems = [];
        const traps = [];
        const spikes = [];
        const lightningTiles = [];
        const swingingBlades = [];
        const fallingDebris = [];
        const collapsingPlatforms = [];
        const rainClouds = [];
        const rainDrops = [];

        // ===============================================
        // LEVEL DESIGN - BOTH PAGES (Like Level 1)
        // ===============================================
        function initializeBothPages() {
            // Clear all arrays
            platforms.length = 0;
            movingPlatforms.length = 0;
            spikes.length = 0;
            lightningTiles.length = 0;
            collapsingPlatforms.length = 0;
            rainClouds.length = 0;
            rainDrops.length = 0;
            collectibles.length = 0;
            ropes.length = 0;
            waterPits.length = 0;
            timeBoosts.length = 0;
            traps.length = 0;

            // PAGE 1 PLATFORMS (Water Relic Collection Area)
            // Ground platform
            platforms.push({ x: 0, y: 520, width: 1200, height: 80, stable: true, color: '#654321' });
            
            // Page 1 jumping platforms
            platforms.push({ x: 150, y: 450, width: 100, height: 20, stable: true, color: '#654321' });
            platforms.push({ x: 300, y: 380, width: 80, height: 20, stable: true, color: '#654321' });
            platforms.push({ x: 450, y: 320, width: 100, height: 20, stable: true, color: '#654321' });
            platforms.push({ x: 600, y: 260, width: 80, height: 20, stable: true, color: '#654321' });
            platforms.push({ x: 750, y: 200, width: 100, height: 20, stable: true, color: '#654321' }); // Water Relic platform

            // PAGE 2 PLATFORMS (Spirit Tree Journey Area - starts at x: 950)
            platforms.push({ x: 950, y: 450, width: 100, height: 20, stable: true, color: '#654321' });
            platforms.push({ x: 1100, y: 400, width: 80, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 1230, y: 350, width: 100, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 1380, y: 300, width: 90, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 1520, y: 250, width: 100, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 1670, y: 200, width: 120, height: 15, stable: true, color: '#654321' });
            
            // Final platform for Spirit Tree
            platforms.push({ x: 1820, y: 150, width: 200, height: 20, stable: true, color: '#228B22' }); // Green for tree

            // PAGE 1 COLLECTIBLES
            // Water Relic
            collectibles.push({
                x: 780, y: 160, width: 40, height: 40,
                type: 'water-relic', collected: false, color: '#00BFFF'
            });
            
            // Additional gems and clocks on Page 1
            collectibles.push({ x: 180, y: 410, width: 30, height: 30, type: 'gem', collected: false, color: '#FFD700' });
            collectibles.push({ x: 330, y: 340, width: 30, height: 30, type: 'gem', collected: false, color: '#FF1493' });
            collectibles.push({ x: 480, y: 280, width: 30, height: 30, type: 'gem', collected: false, color: '#00FF7F' });
            collectibles.push({ x: 630, y: 220, width: 30, height: 30, type: 'gem', collected: false, color: '#FF4500' });
            
            // Time extension clocks on Page 1
            collectibles.push({ x: 250, y: 480, width: 35, height: 35, type: 'clock', collected: false, color: '#4169E1' });
            collectibles.push({ x: 520, y: 420, width: 35, height: 35, type: 'clock', collected: false, color: '#4169E1' });

            // PAGE 2 COLLECTIBLES AND ELEMENTS
            // Dying Spirit Tree (always visible in Page 2)
            trees.push({
                x: 1870, y: 50, width: 100, height: 150,
                type: 'dying', health: 0, glowing: false,
                branches: [
                    // Left side branches
                    { x: -40, y: 30, length: 45, angle: -1.2, hasLeaves: false },
                    { x: -35, y: 50, length: 40, angle: -0.8, hasLeaves: false },
                    { x: -25, y: 70, length: 35, angle: -0.5, hasLeaves: false },
                    { x: -20, y: 90, length: 30, angle: -0.3, hasLeaves: false },
                    // Right side branches
                    { x: 40, y: 35, length: 42, angle: 1.2, hasLeaves: false },
                    { x: 35, y: 55, length: 38, angle: 0.9, hasLeaves: false },
                    { x: 25, y: 75, length: 36, angle: 0.6, hasLeaves: false },
                    { x: 20, y: 95, length: 32, angle: 0.4, hasLeaves: false }
                ],
                leaves: [],
                animatingLeaves: false,
                leafAnimationStep: 0
            });

            // PAGE 1 OBSTACLES & DYNAMIC ELEMENTS
            // Spikes with different timers
            spikes.push({ x: 250, y: 505, width: 60, height: 15, active: true, timer: 30 });
            spikes.push({ x: 450, y: 505, width: 80, height: 15, active: true, timer: 60 });
            spikes.push({ x: 650, y: 505, width: 70, height: 15, active: true, timer: 120 });
            
            // Interval spikes along the dangerous path
            spikes.push({ x: 380, y: 505, width: 40, height: 15, active: false, timer: 0, interval: 120 });
            spikes.push({ x: 500, y: 505, width: 50, height: 15, active: false, timer: 60, interval: 140 });
            spikes.push({ x: 680, y: 505, width: 45, height: 15, active: false, timer: 30, interval: 100 });
            
            // Collapsing platforms with short delay
            collapsingPlatforms.push({
                x: 450, y: 300, width: 100, height: 15,
                collapseTimer: 0, collapsing: false, collapsed: false,
                collapseDelay: 90, color: '#CD853F'
            });
            collapsingPlatforms.push({
                x: 650, y: 220, width: 90, height: 15,
                collapseTimer: 0, collapsing: false, collapsed: false,
                collapseDelay: 75, color: '#CD853F'
            });
            
            // Moving platform
            movingPlatforms.push({
                x: 550, y: 180, width: 60, height: 12,
                startX: 530, endX: 700, speed: 3, direction: 1,
                color: '#4169E1', type: 'horizontal'
            });
            
            // Dark rain clouds that move and drop rain
            rainClouds.push({
                x: 200, y: 50, width: 120, height: 40,
                speed: 0.8, direction: 1, startX: 150, endX: 500,
                rainTimer: 0, rainInterval: 180, raining: false
            });
            rainClouds.push({
                x: 600, y: 30, width: 100, height: 35,
                speed: 1.2, direction: -1, startX: 400, endX: 800,
                rainTimer: 60, rainInterval: 200, raining: false
            });

            // Lightning strike system - targets platforms dynamically
            lightningTiles.push({
                x: 300, y: 360, width: 100, height: 20,
                strikeTimer: 0, strikeInterval: 240, warning: false, striking: false
            });
            lightningTiles.push({
                x: 450, y: 300, width: 120, height: 20,
                strikeTimer: 60, strikeInterval: 300, warning: false, striking: false
            });
            lightningTiles.push({
                x: 600, y: 240, width: 100, height: 20,
                strikeTimer: 120, strikeInterval: 280, warning: false, striking: false
            });
            lightningTiles.push({
                x: 750, y: 180, width: 120, height: 20,
                strikeTimer: 180, strikeInterval: 320, warning: false, striking: false
            });

            // PAGE 1 ROPES
            ropes.push({ x: 380, y: 150, width: 10, height: 220 });
            ropes.push({ x: 680, y: 100, width: 10, height: 280 });

            // PAGE 1 WATER PITS
            waterPits.push({ x: 200, y: 520, width: 120, height: 80 });
            waterPits.push({ x: 400, y: 520, width: 150, height: 80 });
            waterPits.push({ x: 620, y: 520, width: 130, height: 80 });

            // PAGE 2 DYNAMIC ELEMENTS
            // More challenging collapsing platforms in Page 2
            collapsingPlatforms.push({
                x: 1230, y: 330, width: 100, height: 15,
                collapseTimer: 0, collapsing: false, collapsed: false,
                collapseDelay: 60, color: '#CD853F'
            });
            collapsingPlatforms.push({
                x: 1520, y: 230, width: 100, height: 15,
                collapseTimer: 0, collapsing: false, collapsed: false,
                collapseDelay: 45, color: '#CD853F'
            });
            
            // Moving platforms in Page 2
            movingPlatforms.push({
                x: 1350, y: 280, width: 80, height: 12,
                startX: 1320, endX: 1450, speed: 2, direction: 1,
                color: '#4169E1', type: 'horizontal'
            });
            movingPlatforms.push({
                x: 1600, y: 180, width: 70, height: 12,
                startX: 1580, endX: 1720, speed: 2.5, direction: -1,
                color: '#4169E1', type: 'horizontal'
            });
            
            // Rain clouds over Page 2
            rainClouds.push({
                x: 1200, y: 40, width: 140, height: 45,
                speed: 0.6, direction: 1, startX: 1100, endX: 1400,
                rainTimer: 120, rainInterval: 160, raining: false
            });
            rainClouds.push({
                x: 1600, y: 35, width: 120, height: 40,
                speed: 0.9, direction: -1, startX: 1500, endX: 1800,
                rainTimer: 30, rainInterval: 140, raining: false
            });

            // PAGE 2 ROPES (Green ropes connecting platforms)
            ropes.push({ x: 1000, y: 300, width: 10, height: 150 }); 
            ropes.push({ x: 1150, y: 250, width: 10, height: 150 });
            ropes.push({ x: 1300, y: 200, width: 10, height: 150 });
            ropes.push({ x: 1450, y: 150, width: 10, height: 150 });
            ropes.push({ x: 1600, y: 100, width: 10, height: 150 });

            // PAGE 2 WATER PITS
            waterPits.push({ x: 1050, y: 520, width: 180, height: 80 });
            waterPits.push({ x: 1280, y: 520, width: 200, height: 80 });
            waterPits.push({ x: 1530, y: 520, width: 180, height: 80 });
            waterPits.push({ x: 1730, y: 520, width: 190, height: 80 });

            // Reset player to starting position
            player.x = 75;
            player.y = 480;
            player.velocityX = 0;
            player.velocityY = 0;
            
            // Reset camera
            game.camera.x = 0;
        }

        // ===============================================
        // LEVEL DESIGN - PAGE 1 (Water Relic Collection)
        // ===============================================
        function initializePage1() {
            // Clear all arrays
            platforms.length = 0;
            movingPlatforms.length = 0;
            ropes.length = 0;
            collectibles.length = 0;
            waterPits.length = 0;
            timeBoosts.length = 0;
            trees.length = 0;
            coins.length = 0;
            gems.length = 0;
            traps.length = 0;
            spikes.length = 0;
            lightningTiles.length = 0;
            collapsingPlatforms.length = 0;
            rainClouds.length = 0;

            // Starting platform
            platforms.push({ x: 50, y: 500, width: 150, height: 20, stable: true, color: '#654321' });
            
            // More challenging crumbling platforms
            platforms.push({ x: 220, y: 460, width: 80, height: 12, stable: false, color: '#8B4513', crumbleTimer: 0 });
            platforms.push({ x: 350, y: 400, width: 70, height: 12, stable: false, color: '#8B4513', crumbleTimer: 0 });
            platforms.push({ x: 480, y: 340, width: 65, height: 12, stable: false, color: '#8B4513', crumbleTimer: 0 });
            platforms.push({ x: 600, y: 280, width: 75, height: 12, stable: false, color: '#8B4513', crumbleTimer: 0 });
            
            // Moving platforms (reduced to 2)
            movingPlatforms.push({ 
                x: 300, y: 380, width: 80, height: 15, 
                startX: 280, endX: 420, speed: 2, direction: 1, 
                color: '#4682B4', type: 'horizontal' 
            });
            movingPlatforms.push({ 
                x: 720, y: 200, width: 90, height: 15, 
                startY: 180, endY: 350, speed: 1.8, direction: 1, 
                color: '#4682B4', type: 'vertical' 
            });
            
            // Larger, more dangerous water pits
            waterPits.push({ x: 180, y: 520, width: 140, height: 80 });
            waterPits.push({ x: 380, y: 520, width: 160, height: 80 });
            waterPits.push({ x: 580, y: 520, width: 180, height: 80 });
            waterPits.push({ x: 800, y: 520, width: 120, height: 80 });
            
            // Spike traps
            spikes.push({ x: 250, y: 505, width: 60, height: 15, active: true, timer: 0 });
            spikes.push({ x: 450, y: 505, width: 80, height: 15, active: true, timer: 60 });
            spikes.push({ x: 650, y: 505, width: 70, height: 15, active: true, timer: 120 });
            
            // Green ropes in more challenging positions
            ropes.push({ x: 380, y: 150, width: 10, height: 220 });
            ropes.push({ x: 680, y: 100, width: 10, height: 280 });
            ropes.push({ x: 880, y: 120, width: 10, height: 260 });
            
            // Fewer stable platforms - more challenge
            platforms.push({ x: 850, y: 180, width: 100, height: 20, stable: true, color: '#654321' });
            
            // Tree platforms (ground for trees to sit on)
            platforms.push({ x: 100, y: 500, width: 100, height: 20, stable: true, color: '#654321' }); // For tree at x:150
            platforms.push({ x: 400, y: 500, width: 100, height: 20, stable: true, color: '#654321' }); // For tree at x:450  
            platforms.push({ x: 700, y: 500, width: 100, height: 20, stable: true, color: '#654321' }); // For tree at x:750
            platforms.push({ x: 1050, y: 500, width: 100, height: 20, stable: true, color: '#654321' }); // For tree at x:1100
            
            // Background trees (same as Level 1, now positioned on platforms)
            trees.push({ x: 150, y: 500, height: 200, type: 'tall' });
            trees.push({ x: 450, y: 500, height: 250, type: 'medium' });
            trees.push({ x: 750, y: 500, height: 300, type: 'tall' });
            trees.push({ x: 1100, y: 500, height: 220, type: 'medium' });
            
            // Fewer time boosts - make time management critical
            timeBoosts.push({ x: 370, y: 350, width: 20, height: 20, collected: false, type: 'clock' });
            timeBoosts.push({ x: 730, y: 150, width: 20, height: 20, collected: false, type: 'clock' });
            
            // More valuable collectibles in dangerous spots
            coins.push({ x: 290, y: 430, width: 15, height: 15, collected: false, type: 'coin', points: 100 });
            coins.push({ x: 530, y: 320, width: 15, height: 15, collected: false, type: 'coin', points: 100 });
            coins.push({ x: 680, y: 240, width: 15, height: 15, collected: false, type: 'coin', points: 100 });
            coins.push({ x: 870, y: 140, width: 15, height: 15, collected: false, type: 'coin', points: 100 });
            
            gems.push({ x: 410, y: 350, width: 18, height: 18, collected: false, type: 'gem', points: 250 });
            gems.push({ x: 750, y: 160, width: 18, height: 18, collected: false, type: 'gem', points: 250 });
            
            // === ADVANCED TRAP SYSTEMS FOR WATER RELIC PATH ===
            
            // Dynamic Lightning Strike System - targets different platforms each time
            // Initialize with empty array - lightning will dynamically target platforms
            
            // Collapsing platforms with short delay
            collapsingPlatforms.push({
                x: 450, y: 300, width: 100, height: 15,
                collapseTimer: 0, collapsing: false, collapsed: false,
                collapseDelay: 90, color: '#CD853F'
            });
            collapsingPlatforms.push({
                x: 650, y: 220, width: 90, height: 15,
                collapseTimer: 0, collapsing: false, collapsed: false,
                collapseDelay: 75, color: '#CD853F'
            });
            collapsingPlatforms.push({
                x: 820, y: 160, width: 110, height: 15,
                collapseTimer: 0, collapsing: false, collapsed: false,
                collapseDelay: 60, color: '#CD853F'
            });
            
            // Dark rain clouds that move and drop rain
            rainClouds.push({
                x: 200, y: 50, width: 120, height: 40,
                speed: 0.8, direction: 1, startX: 150, endX: 500,
                rainTimer: 0, rainInterval: 180, raining: false
            });
            rainClouds.push({
                x: 600, y: 30, width: 100, height: 35,
                speed: 1.2, direction: -1, startX: 400, endX: 800,
                rainTimer: 60, rainInterval: 200, raining: false
            });
            rainClouds.push({
                x: 900, y: 40, width: 140, height: 45,
                speed: 0.6, direction: 1, startX: 850, endX: 1100,
                rainTimer: 120, rainInterval: 160, raining: false
            });
            
            // One additional challenging moving platform
            movingPlatforms.push({
                x: 550, y: 180, width: 60, height: 12,
                startX: 530, endX: 700, speed: 3, direction: 1,
                color: '#4169E1', type: 'horizontal'
            });
            
            // Interval spikes along the dangerous path
            spikes.push({ x: 380, y: 505, width: 40, height: 15, active: false, timer: 0, interval: 120 });
            spikes.push({ x: 500, y: 505, width: 50, height: 15, active: false, timer: 60, interval: 140 });
            spikes.push({ x: 680, y: 505, width: 45, height: 15, active: false, timer: 30, interval: 100 });
            spikes.push({ x: 850, y: 505, width: 60, height: 15, active: false, timer: 90, interval: 130 });
            
            // Water Relic in visually prominent but extremely challenging position
            collectibles.push({
                x: 1020, y: 80, width: 40, height: 40,
                type: 'water-relic', collected: false, color: '#00BFFF'
            });
            
            // Additional gems and clocks on Page 2
            collectibles.push({ x: 980, y: 410, width: 30, height: 30, type: 'gem', collected: false, color: '#9932CC' });
            collectibles.push({ x: 1130, y: 360, width: 30, height: 30, type: 'gem', collected: false, color: '#FFD700' });
            collectibles.push({ x: 1260, y: 310, width: 30, height: 30, type: 'gem', collected: false, color: '#00CED1' });
            collectibles.push({ x: 1410, y: 260, width: 30, height: 30, type: 'gem', collected: false, color: '#FF69B4' });
            collectibles.push({ x: 1550, y: 210, width: 30, height: 30, type: 'gem', collected: false, color: '#32CD32' });
            collectibles.push({ x: 1700, y: 160, width: 30, height: 30, type: 'gem', collected: false, color: '#FF6347' });
            
            // Time extension clocks on Page 2  
            collectibles.push({ x: 1050, y: 480, width: 35, height: 35, type: 'clock', collected: false, color: '#4169E1' });
            collectibles.push({ x: 1300, y: 480, width: 35, height: 35, type: 'clock', collected: false, color: '#4169E1' });
            collectibles.push({ x: 1750, y: 480, width: 35, height: 35, type: 'clock', collected: false, color: '#4169E1' });
            
            // Final gauntlet - multiple hazards to reach relic
            platforms.push({ x: 980, y: 120, width: 100, height: 12, stable: false, color: '#8B4513', crumbleTimer: 0 });
            
            // Safe zone after collecting relic
            platforms.push({ x: 1150, y: 500, width: 200, height: 20, stable: true, color: '#4682B4' });
        }

        // ===============================================
        // LEVEL DESIGN - PAGE 2 (Spirit Tree Journey)
        // ===============================================
        function initializePage2() {
            platforms.length = 0;
            ropes.length = 0;
            collectibles.length = 0;
            waterPits.length = 0;
            timeBoosts.length = 0;

            // Reset player position for page 2
            player.x = 100;
            player.y = 400;

            // Starting platform for page 2
            platforms.push({ x: 50, y: 500, width: 150, height: 20, stable: true, color: '#654321' });
            
            // More challenging obstacles
            platforms.push({ x: 250, y: 430, width: 80, height: 15, stable: false, color: '#8B4513', crumbleTimer: 0 });
            platforms.push({ x: 380, y: 360, width: 70, height: 15, stable: false, color: '#8B4513', crumbleTimer: 0 });
            platforms.push({ x: 500, y: 290, width: 90, height: 15, stable: false, color: '#8B4513', crumbleTimer: 0 });
            
            // Larger water hazards
            waterPits.push({ x: 200, y: 520, width: 150, height: 80 });
            waterPits.push({ x: 420, y: 520, width: 180, height: 80 });
            
            // Multiple rope sections
            ropes.push({ x: 350, y: 150, width: 10, height: 280 });
            ropes.push({ x: 620, y: 100, width: 10, height: 320 });
            ropes.push({ x: 850, y: 120, width: 10, height: 300 });
            
            // Final stretch platforms
            platforms.push({ x: 700, y: 250, width: 100, height: 20, stable: true, color: '#654321' });
            platforms.push({ x: 870, y: 200, width: 120, height: 20, stable: true, color: '#654321' });
            platforms.push({ x: 1050, y: 150, width: 150, height: 20, stable: true, color: '#654321' });
            
            // Final time boosts
            timeBoosts.push({ x: 450, y: 250, width: 25, height: 25, collected: false });
            timeBoosts.push({ x: 750, y: 210, width: 25, height: 25, collected: false });
            
            // Spirit Tree will only appear in Stage 2
        }

        // ===============================================
        // PAGE 2 INITIALIZATION (Spirit Tree Journey)
        // ===============================================
        function initializePage2() {
            // Clear page 1 obstacles but keep some platforms
            spikes.length = 0;
            lightningTiles.length = 0;
            collapsingPlatforms.length = 0;
            movingPlatforms.length = 0;
            rainClouds.length = 0;
            rainDrops.length = 0;
            
            // Clear existing platforms except tree platforms
            platforms.length = 0;
            
            // Page 2: Path to Spirit Tree with green ropes and water pits
            // Starting platform
            platforms.push({ x: 50, y: 500, width: 150, height: 20, stable: true, color: '#654321' });
            
            // Reset player to safe starting position on the platform for page 2
            player.x = 75;
            player.y = 460; // On top of the starting platform (500 - 40 height)
            player.velocityX = 0;
            player.velocityY = 0;
            
            // Reset camera to follow player
            game.camera.x = 0;
            
            // Bridge platforms over water pits
            platforms.push({ x: 250, y: 450, width: 100, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 400, y: 400, width: 80, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 550, y: 350, width: 100, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 700, y: 300, width: 90, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 850, y: 250, width: 100, height: 15, stable: true, color: '#654321' });
            platforms.push({ x: 1000, y: 200, width: 120, height: 15, stable: true, color: '#654321' });
            
            // Final platform for Spirit Tree
            platforms.push({ x: 1150, y: 150, width: 200, height: 20, stable: true, color: '#228B22' }); // Green for tree
            
            // Green ropes connecting platforms
            ropes.push({ x: 320, y: 300, width: 10, height: 150 }); // Between platforms
            ropes.push({ x: 470, y: 250, width: 10, height: 150 });
            ropes.push({ x: 620, y: 200, width: 10, height: 150 });
            ropes.push({ x: 770, y: 150, width: 10, height: 150 });
            ropes.push({ x: 920, y: 100, width: 10, height: 150 });
            
            // Large water pits as obstacles
            waterPits.length = 0; // Clear existing
            waterPits.push({ x: 180, y: 520, width: 180, height: 80 });
            waterPits.push({ x: 380, y: 520, width: 200, height: 80 });
            waterPits.push({ x: 630, y: 520, width: 180, height: 80 });
            waterPits.push({ x: 830, y: 520, width: 190, height: 80 });
            
            // Timer collectibles (1-2 as requested)
            timeBoosts.length = 0; // Clear existing
            timeBoosts.push({ x: 450, y: 360, width: 25, height: 25, collected: false, type: 'clock' });
            timeBoosts.push({ x: 750, y: 260, width: 25, height: 25, collected: false, type: 'clock' });
            
            // Add Spirit Tree collectible for Page 2 only
            collectibles.length = 0; // Clear existing collectibles
            collectibles.push({
                x: 1200, y: 100, width: 60, height: 70,
                type: 'spirit-tree', collected: false, color: '#90EE90'
            });
            
            showMessage("🌳 Page 2: Navigate to the dying Spirit Tree using the green ropes!");
        }

        // ===============================================
        // PHYSICS AND COLLISION DETECTION
        // ===============================================
        function updatePlayer() {
            // Handle input
            if (game.keys['a'] || game.keys['A'] || game.keys['ArrowLeft']) {
                player.velocityX = -player.speed;
                player.facingRight = false;
            } else if (game.keys['d'] || game.keys['D'] || game.keys['ArrowRight']) {
                player.velocityX = player.speed;
                player.facingRight = true;
            } else {
                player.velocityX *= 0.8; // Friction
            }

            // Jumping
            if ((game.keys[' '] || game.keys['w'] || game.keys['W'] || game.keys['ArrowUp']) && 
                (player.onGround || player.onRope)) {
                player.velocityY = -player.jumpPower;
                player.onGround = false;
                player.onRope = false;
            }

            // Rope climbing (same as Level 1)
            if (player.onRope) {
                if (game.keys['w'] || game.keys['W'] || game.keys['ArrowUp']) {
                    player.velocityY = -player.speed;
                } else if (game.keys['s'] || game.keys['S'] || game.keys['ArrowDown']) {
                    player.velocityY = player.speed;
                } else {
                    player.velocityY = 0;
                }
                player.velocityX *= 0.5; // Reduced horizontal movement on rope
            } else {
                // Gravity
                player.velocityY += 0.8;
                if (player.velocityY > 15) player.velocityY = 15; // Terminal velocity
            }

            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;

            // Reset ground state
            player.onGround = false;
            player.onRope = false;

            // Update moving platforms
            updateMovingPlatforms();
            
            // Update all trap systems
            updateTraps();
            updateSpikes();
            updateLightningTiles();
            updateCollapsingPlatforms();
            updateRainClouds();

            // Check rope collisions first
            checkRopeCollisions();
            
            // Check platform collisions (including moving platforms)
            checkPlatformCollisions();
            checkMovingPlatformCollisions();
            
            // Check trap collisions
            checkTrapCollisions();
            
            // Check all collision systems
            checkSpikeCollisions();
            checkLightningCollisions();
            checkCollapsingPlatformCollisions();
            
            // Check water pit collisions
            checkWaterCollisions();
            
            // Check collectible collisions
            checkCollectibleCollisions();
            
            // Check time boost collisions
            checkTimeBoostCollisions();

            // Keep player in bounds
            if (player.x < 0) player.x = 0;
            if (player.x > game.mapWidth - player.width) player.x = game.mapWidth - player.width;
            
            // Death by falling
            if (player.y > canvas.height + 50) {
                respawnPlayer();
            }
        }

        function checkRopeCollisions() {
            for (let rope of ropes) {
                if (player.x < rope.x + rope.width &&
                    player.x + player.width > rope.x &&
                    player.y < rope.y + rope.height &&
                    player.y + player.height > rope.y) {
                    player.onRope = true;
                    player.x = rope.x - player.width / 2 + rope.width / 2; // Center on rope
                    break;
                }
            }
        }

        function checkPlatformCollisions() {
            for (let platform of platforms) {
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y < platform.y + platform.height &&
                    player.y + player.height > platform.y) {
                    
                    // Landing on top of platform
                    if (player.velocityY > 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        
                        // Handle crumbling platforms
                        if (!platform.stable) {
                            platform.crumbleTimer++;
                            if (platform.crumbleTimer > 90) { // 1.5 seconds at 60fps
                                platforms.splice(platforms.indexOf(platform), 1);
                            }
                        }
                    }
                }
            }
        }

        function checkWaterCollisions() {
            for (let water of waterPits) {
                if (player.x < water.x + water.width &&
                    player.x + player.width > water.x &&
                    player.y < water.y + water.height &&
                    player.y + player.height > water.y) {
                    respawnPlayer();
                    break;
                }
            }
        }

        function checkCollectibleCollisions() {
            for (let collectible of collectibles) {
                if (!collectible.collected &&
                    player.x < collectible.x + collectible.width &&
                    player.x + player.width > collectible.x &&
                    player.y < collectible.y + collectible.height &&
                    player.y + player.height > collectible.y) {
                    
                    collectible.collected = true;
                    
                    if (collectible.type === 'water-relic') {
                        game.hasWaterRelic = true;
                        game.score += 1000;
                        // Show water relic icon
                        document.getElementById('waterRelicContainer').style.display = 'block';
                        showMessage("💧 WATER RELIC ACQUIRED! The Spirit Tree awaits in Page 2!");
                        
                        // Add the Spirit Tree to Page 2
                        addSpiritTree();
                        
                    } else if (collectible.type === 'spirit-tree') {
                        if (game.hasForestRelic && game.hasEmberRelic && game.hasWaterRelic) {
                            completeGame();
                        } else {
                            showMessage("🔮 You need all three relics to revive the Spirit Tree!");
                        }
                    }
                }
            }
        }

        function checkTimeBoostCollisions() {
            for (let boost of timeBoosts) {
                if (!boost.collected &&
                    player.x < boost.x + boost.width &&
                    player.x + player.width > boost.x &&
                    player.y < boost.y + boost.height &&
                    player.y + player.height > boost.y) {
                    
                    boost.collected = true;
                    game.timeLeft += 10;
                    game.score += 500;
                    showMessage("⏰ +10 seconds!");
                }
            }
            
            // Check coin collisions
            for (let coin of coins) {
                if (!coin.collected &&
                    player.x < coin.x + coin.width &&
                    player.x + player.width > coin.x &&
                    player.y < coin.y + coin.height &&
                    player.y + player.height > coin.y) {
                    
                    coin.collected = true;
                    game.score += coin.points;
                    showMessage(`💰 +${coin.points} points!`);
                }
            }
            
            // Check gem collisions
            for (let gem of gems) {
                if (!gem.collected &&
                    player.x < gem.x + gem.width &&
                    player.x + gem.width > gem.x &&
                    player.y < gem.y + gem.height &&
                    player.y + gem.height > gem.y) {
                    
                    gem.collected = true;
                    game.score += gem.points;
                    showMessage(`💎 +${gem.points} points!`);
                }
            }
        }

        function updateMovingPlatforms() {
            for (let platform of movingPlatforms) {
                if (platform.type === 'horizontal') {
                    platform.x += platform.speed * platform.direction;
                    if (platform.x <= platform.startX || platform.x >= platform.endX) {
                        platform.direction *= -1;
                    }
                } else if (platform.type === 'vertical') {
                    platform.y += platform.speed * platform.direction;
                    if (platform.y <= platform.startY || platform.y >= platform.endY) {
                        platform.direction *= -1;
                    }
                }
            }
        }

        function updateTraps() {
            for (let trap of traps) {
                if (trap.type === 'falling_rock' && trap.active) {
                    // Check if player is in trigger zone
                    if (player.x >= trap.triggerX && player.x <= trap.triggerX + trap.triggerWidth && !trap.falling) {
                        trap.falling = true;
                        trap.fallSpeed = 2;
                        showMessage("⚠️ Rock falling!");
                    }
                    
                    // Update falling rock
                    if (trap.falling) {
                        trap.y += trap.fallSpeed;
                        trap.fallSpeed += 0.5; // Gravity acceleration
                        
                        // Reset if rock hits ground
                        if (trap.y > canvas.height) {
                            setTimeout(() => {
                                trap.y = trap.type === 'falling_rock' ? 100 : 80;
                                trap.falling = false;
                                trap.fallSpeed = 0;
                            }, 3000);
                        }
                    }
                }
            }
        }

        function updateSpikes() {
            for (let spike of spikes) {
                spike.timer++;
                if (spike.timer >= spike.interval) {
                    spike.active = !spike.active;
                    spike.timer = 0;
                }
            }
        }

        function updateLightningTiles() {
            // Dynamic lightning system - create new strikes on random platforms
            if (Math.random() < 0.005) { // 0.5% chance per frame to create lightning
                createRandomLightningStrike();
            }
            
            // Update existing lightning strikes
            for (let i = lightningTiles.length - 1; i >= 0; i--) {
                let tile = lightningTiles[i];
                tile.strikeTimer++;
                
                if (tile.strikeTimer >= tile.strikeInterval - 60 && !tile.warning) {
                    tile.warning = true;
                }
                
                if (tile.strikeTimer >= tile.strikeInterval) {
                    tile.striking = true;
                    tile.warning = false;
                    
                    setTimeout(() => {
                        tile.striking = false;
                        // Remove the lightning tile after strike
                        lightningTiles.splice(i, 1);
                    }, 30); // Strike lasts 0.5 seconds
                }
            }
        }

        function createRandomLightningStrike() {
            // Get all available platforms for lightning strikes
            const targetablePlatforms = [];
            
            // Add regular platforms
            for (let platform of platforms) {
                if (platform.stable) {
                    targetablePlatforms.push({
                        x: platform.x,
                        y: platform.y - 5, // Strike slightly above platform
                        width: platform.width,
                        height: 25
                    });
                }
            }
            
            // Add moving platforms
            for (let platform of movingPlatforms) {
                targetablePlatforms.push({
                    x: platform.x,
                    y: platform.y - 5,
                    width: platform.width,
                    height: 25
                });
            }
            
            // Add collapsing platforms that haven't collapsed yet
            for (let platform of collapsingPlatforms) {
                if (!platform.collapsed) {
                    targetablePlatforms.push({
                        x: platform.x,
                        y: platform.y - 5,
                        width: platform.width,
                        height: 25
                    });
                }
            }
            
            // Select random platform and create lightning strike
            if (targetablePlatforms.length > 0) {
                const randomIndex = Math.floor(Math.random() * targetablePlatforms.length);
                const target = targetablePlatforms[randomIndex];
                
                lightningTiles.push({
                    x: target.x,
                    y: target.y,
                    width: target.width,
                    height: target.height,
                    strikeTimer: 0,
                    warning: false,
                    striking: false,
                    strikeInterval: 120 + Math.random() * 60 // 2-3 seconds warning
                });
            }
        }

        function updateCollapsingPlatforms() {
            for (let platform of collapsingPlatforms) {
                if (platform.collapsing && !platform.collapsed) {
                    platform.collapseTimer++;
                    if (platform.collapseTimer >= platform.collapseDelay) {
                        platform.collapsed = true;
                        showMessage("💥 Platform collapsed!");
                    }
                }
            }
        }

        function updateRainClouds() {
            for (let cloud of rainClouds) {
                // Move cloud
                cloud.x += cloud.speed * cloud.direction;
                
                // Bounce at boundaries
                if (cloud.x <= cloud.startX || cloud.x + cloud.width >= cloud.endX) {
                    cloud.direction *= -1;
                }
                
                // Rain timer for visual effects only
                cloud.rainTimer++;
                if (cloud.rainTimer >= cloud.rainInterval) {
                    cloud.raining = true;
                    
                    setTimeout(() => {
                        cloud.raining = false;
                        cloud.rainTimer = 0;
                        cloud.rainInterval = 160 + Math.random() * 80; // Random interval
                    }, 2000); // Rain effect for 2 seconds
                }
            }
        }

        function checkMovingPlatformCollisions() {
            for (let platform of movingPlatforms) {
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y < platform.y + platform.height &&
                    player.y + player.height > platform.y) {
                    
                    // Landing on top of moving platform
                    if (player.velocityY > 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        
                        // Move player with platform
                        if (platform.type === 'horizontal') {
                            player.x += platform.speed * platform.direction;
                        }
                    }
                }
            }
        }

        function checkTrapCollisions() {
            for (let trap of traps) {
                if (trap.falling &&
                    player.x < trap.x + trap.width &&
                    player.x + player.width > trap.x &&
                    player.y < trap.y + trap.height &&
                    player.y + player.height > trap.y) {
                    respawnPlayer();
                    break;
                }
            }
        }

        function checkSpikeCollisions() {
            for (let spike of spikes) {
                if (spike.active &&
                    player.x < spike.x + spike.width &&
                    player.x + player.width > spike.x &&
                    player.y < spike.y + spike.height &&
                    player.y + player.height > spike.y) {
                    showMessage("💀 Pierced by spikes!");
                    respawnPlayer();
                    break;
                }
            }
        }

        function checkLightningCollisions() {
            for (let tile of lightningTiles) {
                if (tile.striking &&
                    player.x < tile.x + tile.width &&
                    player.x + player.width > tile.x &&
                    player.y < tile.y + tile.height &&
                    player.y + player.height > tile.y) {
                    showMessage("⚡ Struck by lightning!");
                    respawnPlayer();
                    break;
                }
            }
        }

        function checkCollapsingPlatformCollisions() {
            for (let platform of collapsingPlatforms) {
                if (!platform.collapsed &&
                    player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y < platform.y + platform.height &&
                    player.y + player.height > platform.y) {
                    
                    // Landing on collapsing platform
                    if (player.velocityY > 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        
                        // Start collapse sequence
                        if (!platform.collapsing) {
                            platform.collapsing = true;
                            showMessage("⚠️ Platform is collapsing!");
                        }
                    }
                }
            }
        }

        function respawnPlayer() {
            game.lives--;
            if (game.lives <= 0) {
                gameOver();
                return;
            }
            
            // Reset to start of current stage
            player.x = 100;
            player.y = 400;
            player.velocityX = 0;
            player.velocityY = 0;
            
            showMessage(`💔 Life lost! Lives remaining: ${game.lives}`);
            updateHUD();
        }

        // ===============================================
        // GAME LOGIC
        // ===============================================
        function updateCamera() {
            // Follow player with smooth camera
            const targetX = player.x - canvas.width / 2;
            game.camera.x += (targetX - game.camera.x) * 0.1;
            
            // Keep camera in bounds
            if (game.camera.x < 0) game.camera.x = 0;
            if (game.camera.x > game.mapWidth - canvas.width) {
                game.camera.x = game.mapWidth - canvas.width;
            }
        }

        function updateTimer() {
            game.timeLeft -= 1/60; // Decrease by 1/60th of a second each frame
            
            if (game.timeLeft <= 0) {
                game.timeLeft = 0;
                gameOver();
            }
            
            updateHUD();
        }

        function updateHUD() {
            document.getElementById('timeLeft').textContent = Math.ceil(game.timeLeft);
            document.getElementById('currentScore').textContent = game.score.toLocaleString();
            // Update lives display using heart icons like Level 1
            for (let i = 1; i <= 3; i++) {
                const heart = document.getElementById(`life${i}`);
                if (heart) {
                    if (i <= game.lives) {
                        heart.classList.remove('lost');
                        heart.textContent = '❤️';
                    } else {
                        heart.classList.add('lost');
                        heart.textContent = '💔';
                    }
                }
            }
            document.getElementById('forestRelic').textContent = game.hasForestRelic ? '✅' : '';
            document.getElementById('emberRelic').textContent = game.hasEmberRelic ? '✅' : '';
            document.getElementById('waterRelic').textContent = game.hasWaterRelic ? '✅' : '';
            
            // Update Spirit Tree score based on collected relics
            let spiritPower = 0;
            if (game.hasForestRelic) spiritPower += 1000;
            if (game.hasEmberRelic) spiritPower += 1000;
            if (game.hasWaterRelic) spiritPower += 1000;
            document.getElementById('spiritTreeScore').textContent = spiritPower;
        }

        function showMessage(text) {
            const messageOverlay = document.getElementById('messageOverlay');
            messageOverlay.textContent = text;
            messageOverlay.style.display = 'block';
            
            setTimeout(() => {
                messageOverlay.style.display = 'none';
            }, 3000);
        }

        function startPageTransition() {
            // Create transition overlay
            const transitionOverlay = document.createElement('div');
            transitionOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: linear-gradient(135deg, rgba(25, 25, 112, 0.95), rgba(0, 0, 0, 0.9));
                z-index: 1000;
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                color: white;
                font-family: 'Cinzel', serif;
                font-size: 24px;
                font-weight: bold;
                text-align: center;
                opacity: 0;
                transition: opacity 0.8s ease-in-out;
            `;
            
            transitionOverlay.innerHTML = `
                <div style="margin-bottom: 30px; font-size: 36px;">🌊</div>
                <div style="margin-bottom: 20px;">Page 1 Complete!</div>
                <div style="font-size: 18px; color: #87CEEB;">Water Relic Secured</div>
                <div style="margin-top: 30px; font-size: 20px;">Entering Page 2...</div>
                <div style="margin-top: 20px; font-size: 16px; color: #90EE90;">🌳 Journey to the Spirit Tree</div>
            `;
            
            document.body.appendChild(transitionOverlay);
            
            // Fade in the overlay
            setTimeout(() => {
                transitionOverlay.style.opacity = '1';
            }, 100);
            
            // After 3 seconds, transition to page 2
            setTimeout(() => {
                // Fade out overlay
                transitionOverlay.style.opacity = '0';
                
                // Initialize page 2
                game.page = 2;
                initializePage2();
                
                // Remove overlay after fade out
                setTimeout(() => {
                    if (transitionOverlay.parentNode) {
                        transitionOverlay.remove();
                    }
                    showMessage("🌳 Page 2: Navigate to the Spirit Tree and complete your quest!");
                }, 800);
            }, 3000);
        }

        function addSpiritTree() {
            // Add Spirit Tree collectible near the dying tree
            collectibles.push({
                x: 1870, y: 100, width: 60, height: 70,
                type: 'spirit-tree', collected: false, color: '#90EE90'
            });
            
            showMessage("🌳 The Spirit Tree collectible has appeared! Collect it to revive the tree!");
        }

        function completeGame() {
            game.gameComplete = true;
            
            // Start cinematic tree revival animation
            showMessage("🌟 All relics gathered! The Spirit Tree awakens!");
            
            // Cinematic sequence
            setTimeout(() => {
                startTreeRevivalAnimation();
            }, 2000);
        }

        function startTreeRevivalAnimation() {
            game.cinematicMode = true;
            let animationStep = 0;
            
            const animationInterval = setInterval(() => {
                animationStep++;
                
                // Step 1: Tree glows
                if (animationStep === 1) {
                    showMessage("✨ The ancient Spirit Tree stirs with life...");
                    game.treeGlowing = true;
                }
                
                // Step 2: Branches grow
                if (animationStep === 3) {
                    showMessage("🌿 Ancient branches reach toward the heavens...");
                    game.treeBranchesGrowing = true;
                }
                
                // Step 3: Leaves appear gradually
                if (animationStep === 5) {
                    showMessage("🍃 Verdant leaves burst forth with eternal life...");
                    game.treeLeavesAppearing = true;
                    startLeafAnimation();
                }
                
                // Step 4: Full bloom
                if (animationStep === 7) {
                    showMessage("🌳 AZUREON IS SAVED! The Spirit Tree lives again!");
                    game.treeFullyRevived = true;
                    
                    // Calculate final score
                    const timeBonus = Math.floor(game.timeLeft) * 100;
                    game.score += timeBonus;
                    
                    // Show victory screen after animation
                    setTimeout(() => {
                        document.getElementById('finalScore').textContent = game.score.toLocaleString();
                        document.getElementById('finalTime').textContent = Math.ceil(game.timeLeft);
                        document.getElementById('victoryScreen').style.display = 'flex';
                        createCelebrationEffect();
                    }, 3000);
                    
                    clearInterval(animationInterval);
                }
            }, 2000); // 2 seconds between each step
        }

        function startLeafAnimation() {
            const spiritTree = trees.find(t => t.type === 'dying');
            if (!spiritTree) {
                console.log("ERROR: No dying tree found!");
                return;
            }
            
            console.log("🍃 Starting leaf animation!");
            console.log("Tree found at position:", spiritTree.x, spiritTree.y);
            console.log("Number of branches:", spiritTree.branches.length);
            console.log("game.treeLeavesAppearing:", game.treeLeavesAppearing);
            
            let branchIndex = 0;
            
            const leafInterval = setInterval(() => {
                if (branchIndex < spiritTree.branches.length) {
                    // Add leaves to the current branch
                    spiritTree.branches[branchIndex].hasLeaves = true;
                    console.log("🌿 Added leaves to branch", branchIndex, "- hasLeaves:", spiritTree.branches[branchIndex].hasLeaves);
                    
                    // Show visual message for each branch
                    showMessage(`🍃 Leaves growing on branch ${branchIndex + 1}/${spiritTree.branches.length}`);
                    
                    branchIndex++;
                } else {
                    console.log("✅ Leaf animation complete! All branches have leaves.");
                    game.treeFullyRevived = true;
                    showMessage("🌳 The Spirit Tree has been fully revived!");
                    clearInterval(leafInterval);
                    
                    // Trigger game completion after a short delay
                    setTimeout(() => {
                        showMessage("🌟 AZUREON IS SAVED! The realm is restored!");
                        
                        // Calculate final score
                        const timeBonus = Math.floor(game.timeLeft) * 100;
                        game.score += timeBonus;
                        
                        // Show victory screen
                        setTimeout(() => {
                            document.getElementById('finalScore').textContent = game.score.toLocaleString();
                            document.getElementById('finalTime').textContent = Math.ceil(game.timeLeft);
                            document.getElementById('victoryScreen').style.display = 'flex';
                            createCelebrationEffect();
                        }, 2000);
                    }, 2000);
                }
            }, 800); // Slower for easier debugging
        }

        function gameOver() {
            game.gameComplete = true;
            showRetryScreen();
        }

        function showRetryScreen() {
            // Create retry screen overlay
            const retryScreen = document.createElement('div');
            retryScreen.id = 'retryScreen';
            retryScreen.innerHTML = `
                <div style="background: linear-gradient(135deg, rgba(139, 0, 0, 0.95), rgba(0, 0, 0, 0.9)); 
                           position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
                           display: flex; align-items: center; justify-content: center; z-index: 1000;
                           font-family: 'Cinzel', serif;">
                    <div style="text-align: center; color: white; max-width: 600px; padding: 40px;">
                        <h1 style="font-size: 3em; color: #ff6b6b; margin-bottom: 20px; text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);">
                            ⏰ TIME'S UP!
                        </h1>
                        <div style="font-size: 1.5em; margin-bottom: 30px; color: #ffd700;">
                            The Spirit Tree's light grows dimmer...
                        </div>
                        <div style="font-size: 1.2em; margin-bottom: 20px;">
                            <strong>Your Score:</strong> ${game.score.toLocaleString()}
                        </div>
                        <div style="font-size: 1em; margin-bottom: 40px; color: #cccccc;">
                            The ancient guardian needs more time to gather the relics.<br>
                            Will you try again to save Azureon?
                        </div>
                        <div style="display: flex; gap: 20px; justify-content: center;">
                            <button onclick="window.location.href='level4_game.html'" 
                                    style="padding: 15px 30px; font-size: 1.1em; background: linear-gradient(45deg, #28a745, #20c997);
                                           border: none; border-radius: 10px; color: white; cursor: pointer; font-family: 'Cinzel', serif;
                                           box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4); transition: all 0.3s ease;"
                                    onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(40, 167, 69, 0.6)';"
                                    onmouseout="this.style.transform='translateY(0px)'; this.style.boxShadow='0 4px 15px rgba(40, 167, 69, 0.4)';">
                                🔄 Try Again
                            </button>
                            <button onclick="window.location.href='level4.html'" 
                                    style="padding: 15px 30px; font-size: 1.1em; background: linear-gradient(45deg, #6c757d, #495057);
                                           border: none; border-radius: 10px; color: white; cursor: pointer; font-family: 'Cinzel', serif;
                                           box-shadow: 0 4px 15px rgba(108, 117, 125, 0.4); transition: all 0.3s ease;"
                                    onmouseover="this.style.transform='translateY(-3px)'; this.style.boxShadow='0 6px 20px rgba(108, 117, 125, 0.6)';"
                                    onmouseout="this.style.transform='translateY(0px)'; this.style.boxShadow='0 4px 15px rgba(108, 117, 125, 0.4)';">
                                🏠 Level Select
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(retryScreen);
        }

        function drawAnimatedSpiritTree(x, y, width, height) {
            const time = Date.now() * 0.003;
            
            // Tree trunk - starts small and grows
            let trunkWidth = 20;
            let trunkHeight = 40;
            
            if (game.treeBranchesGrowing) {
                trunkWidth += Math.sin(time * 2) * 5;
                trunkHeight += 10;
            }
            
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + width/2 - trunkWidth/2, y + height - trunkHeight, trunkWidth, trunkHeight);
            
            // Tree glow effect
            if (game.treeGlowing || game.treeFullyRevived) {
                const glowIntensity = game.treeFullyRevived ? 40 : 20;
                const glow = Math.sin(time * 3) * glowIntensity + glowIntensity;
                ctx.shadowBlur = glow;
                ctx.shadowColor = '#00FF00';
                
                // Magical particles around tree
                for (let i = 0; i < (game.treeFullyRevived ? 15 : 8); i++) {
                    const particleX = x + width/2 + Math.cos(time + i) * (30 + Math.sin(time) * 10);
                    const particleY = y + height/2 + Math.sin(time + i) * (25 + Math.cos(time) * 8);
                    
                    ctx.fillStyle = `rgba(0, 255, 0, ${0.8 + Math.sin(time * 2 + i) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, 3 + Math.sin(time * 4 + i) * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }
            
            // Growing branches
            if (game.treeBranchesGrowing || game.treeLeavesAppearing || game.treeFullyRevived) {
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 4;
                
                const branchGrowth = game.treeFullyRevived ? 1 : Math.min(1, (time % 10) / 5);
                
                // Main branches
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + time * 0.2;
                    const branchLength = (30 + i * 5) * branchGrowth;
                    const startX = x + width/2;
                    const startY = y + height/2;
                    const endX = startX + Math.cos(angle) * branchLength;
                    const endY = startY + Math.sin(angle) * branchLength;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            }
            
            // Leaves appearing
            if (game.treeLeavesAppearing || game.treeFullyRevived) {
                const leafCount = game.treeFullyRevived ? 25 : 15;
                ctx.fillStyle = '#32CD32';
                
                for (let i = 0; i < leafCount; i++) {
                    const leafAngle = (i / leafCount) * Math.PI * 2 + time * 0.5;
                    const leafDistance = 25 + Math.sin(time * 2 + i) * 15;
                    const leafX = x + width/2 + Math.cos(leafAngle) * leafDistance;
                    const leafY = y + height/2 + Math.sin(leafAngle) * leafDistance;
                    const leafSize = 4 + Math.sin(time * 3 + i) * 2;
                    
                    ctx.beginPath();
                    ctx.ellipse(leafX, leafY, leafSize, leafSize * 0.7, leafAngle, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Final form - fully revived tree
            if (game.treeFullyRevived) {
                // Crown of light
                const crownGlow = Math.sin(time * 2) * 20 + 40;
                ctx.fillStyle = `rgba(255, 215, 0, ${0.4 + Math.sin(time) * 0.2})`;
                ctx.beginPath();
                ctx.arc(x + width/2, y + height/2 - 30, crownGlow, 0, Math.PI * 2);
                ctx.fill();
                
                // Golden aura
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x + width/2, y + height/2, 50 + Math.sin(time) * 10, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function createCelebrationEffect() {
            // Create magical particles for the celebration
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '8px';
                    particle.style.height = '8px';
                    particle.style.background = `hsl(${Math.random() * 360}, 70%, 60%)`;
                    particle.style.borderRadius = '50%';
                    particle.style.left = Math.random() * window.innerWidth + 'px';
                    particle.style.top = '-10px';
                    particle.style.pointerEvents = 'none';
                    particle.style.zIndex = '25';
                    document.body.appendChild(particle);

                    particle.animate([
                        { transform: 'translateY(0px) rotate(0deg)', opacity: 1 },
                        { transform: `translateY(${window.innerHeight + 20}px) rotate(360deg)`, opacity: 0 }
                    ], {
                        duration: 3000 + Math.random() * 2000,
                        easing: 'ease-out'
                    }).addEventListener('finish', () => particle.remove());
                }, i * 100);
            }
        }

        // ===============================================
        // RENDERING
        // ===============================================
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Save context for camera
            ctx.save();
            ctx.translate(-game.camera.x, 0);

            // Draw water pits with light blue shade
            ctx.fillStyle = '#87CEEB'; // Light blue water
            for (let water of waterPits) {
                ctx.fillRect(water.x, water.y, water.width, water.height);
                
                // Water surface animation with lighter blue
                ctx.fillStyle = '#B0E0E6'; // Powder blue for surface
                const waveHeight = Math.sin(Date.now() * 0.005) * 2;
                ctx.fillRect(water.x, water.y + waveHeight, water.width, 4);
                
                // Add some transparency effect
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#E0F6FF'; // Very light blue highlight
                ctx.fillRect(water.x, water.y + 2, water.width, 3);
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = '#87CEEB';
            }

            // Draw platforms
            for (let platform of platforms) {
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                // Crumbling effect
                if (!platform.stable && platform.crumbleTimer > 20) {
                    ctx.fillStyle = '#FF6B6B';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(
                            platform.x + Math.random() * platform.width, 
                            platform.y - Math.random() * 5, 
                            2, 2
                        );
                    }
                }
            }

            // Draw moving platforms
            for (let platform of movingPlatforms) {
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                // Moving platform highlight
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(platform.x + 2, platform.y + 2, platform.width - 4, 3);
                
                // Direction indicators
                ctx.fillStyle = '#FFD700';
                if (platform.type === 'horizontal') {
                    // Arrow showing movement direction
                    const arrowX = platform.x + platform.width/2;
                    const arrowY = platform.y - 5;
                    ctx.fillRect(arrowX + (platform.direction * 5), arrowY, 3, 3);
                } else {
                    // Vertical movement indicator
                    const arrowX = platform.x + platform.width/2;
                    const arrowY = platform.y + (platform.direction > 0 ? platform.height + 2 : -8);
                    ctx.fillRect(arrowX, arrowY, 3, 3);
                }
            }

            // Draw spikes
            for (let spike of spikes) {
                if (spike.active) {
                    ctx.fillStyle = '#708090'; // Steel gray
                    // Draw triangular spikes
                    for (let i = 0; i < spike.width; i += 8) {
                        ctx.beginPath();
                        ctx.moveTo(spike.x + i, spike.y + spike.height);
                        ctx.lineTo(spike.x + i + 4, spike.y);
                        ctx.lineTo(spike.x + i + 8, spike.y + spike.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Spike glow when active
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#FF4500';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Retracted spikes
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(spike.x, spike.y + spike.height - 3, spike.width, 3);
                }
            }

            // Draw falling rock traps
            for (let trap of traps) {
                if (trap.type === 'falling_rock') {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                    
                    // Rock texture
                    ctx.fillStyle = '#A0522D';
                    ctx.fillRect(trap.x + 2, trap.y + 2, trap.width - 4, trap.height - 4);
                    
                    if (trap.falling) {
                        // Motion blur effect
                        ctx.fillStyle = 'rgba(139, 69, 19, 0.5)';
                        ctx.fillRect(trap.x, trap.y - trap.fallSpeed * 2, trap.width, trap.fallSpeed * 2);
                    }
                }
            }

            // Draw lightning tiles
            for (let tile of lightningTiles) {
                if (tile.warning) {
                    // Warning flash
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.fillRect(tile.x, tile.y, tile.width, tile.height);
                    
                    // Warning sparks
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(
                            tile.x + Math.random() * tile.width, 
                            tile.y - 10 - Math.random() * 20, 
                            2, 2
                        );
                    }
                } else if (tile.striking) {
                    // Lightning bolt effect
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 5;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00BFFF';
                    
                    ctx.beginPath();
                    ctx.moveTo(tile.x + tile.width/2, 0);
                    ctx.lineTo(tile.x + tile.width/2 - 15, tile.y/3);
                    ctx.lineTo(tile.x + tile.width/2 + 10, tile.y/2);
                    ctx.lineTo(tile.x + tile.width/2 - 5, tile.y);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Lightning impact on tile
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(tile.x, tile.y, tile.width, tile.height);
                }
            }

            // Draw collapsing platforms
            for (let platform of collapsingPlatforms) {
                if (!platform.collapsed) {
                    ctx.fillStyle = platform.color;
                    
                    if (platform.collapsing) {
                        // Shaking effect
                        const shake = Math.random() * 4 - 2;
                        ctx.fillRect(platform.x + shake, platform.y, platform.width, platform.height);
                        
                        // Collapse particles
                        for (let i = 0; i < 8; i++) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(
                                platform.x + Math.random() * platform.width,
                                platform.y + platform.height + Math.random() * 10,
                                3, 3
                            );
                        }
                        ctx.fillStyle = platform.color;
                    } else {
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    }
                    
                    // Platform warning cracks when stepped on
                    if (platform.collapsing) {
                        ctx.strokeStyle = '#8B0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(platform.x + 10, platform.y + 5);
                        ctx.lineTo(platform.x + platform.width - 10, platform.y + 10);
                        ctx.moveTo(platform.x + 20, platform.y + 3);
                        ctx.lineTo(platform.x + platform.width - 20, platform.y + 12);
                        ctx.stroke();
                    }
                }
            }

            // Draw rain clouds and rain
            for (let cloud of rainClouds) {
                // Dark rain cloud
                ctx.fillStyle = '#2F4F4F';
                ctx.beginPath();
                ctx.ellipse(cloud.x + cloud.width/2, cloud.y + cloud.height/2, cloud.width/2, cloud.height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Cloud highlight
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.ellipse(cloud.x + cloud.width/3, cloud.y + cloud.height/3, cloud.width/4, cloud.height/4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Lightning flash when raining
                if (cloud.raining && Math.random() < 0.3) {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cloud.x + cloud.width/2, cloud.y + cloud.height);
                    ctx.lineTo(cloud.x + cloud.width/2 + (Math.random() - 0.5) * 20, cloud.y + cloud.height + 30);
                    ctx.stroke();
                }
            }

            // Draw trees
            for (let tree of trees) {
                if (tree.type === 'dying') {
                    // Draw the Spirit Tree with detailed branches
                    ctx.save();
                    
                    // Tree trunk - gets healthier during revival
                    if (game.treeFullyRevived) {
                        ctx.fillStyle = '#8B4513';
                        ctx.shadowColor = '#90EE90';
                        ctx.shadowBlur = 25;
                    } else if (game.treeGlowing) {
                        ctx.fillStyle = '#704214';
                        ctx.shadowColor = '#90EE90';
                        ctx.shadowBlur = 15;
                    } else {
                        ctx.fillStyle = '#654321';
                    }
                    ctx.fillRect(tree.x - 20, tree.y, 40, tree.height);
                    
                    // Draw individual branches
                    ctx.strokeStyle = game.treeGlowing ? '#8B4513' : '#5D4037';
                    ctx.lineWidth = game.treeBranchesGrowing ? 4 : 3;
                    if (game.treeGlowing) {
                        ctx.shadowColor = '#90EE90';
                        ctx.shadowBlur = 8;
                    }
                    
                    for (let branch of tree.branches) {
                        ctx.beginPath();
                        ctx.moveTo(tree.x + branch.x, tree.y + branch.y);
                        
                        const endX = tree.x + branch.x + Math.cos(branch.angle) * branch.length;
                        const endY = tree.y + branch.y + Math.sin(branch.angle) * branch.length;
                        
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        
                        // Draw leaves on branches if they should have them
                        if (branch.hasLeaves && (game.treeLeavesAppearing || game.treeFullyRevived)) {
                            ctx.fillStyle = game.treeFullyRevived ? '#32CD32' : '#228B22';
                            if (game.treeFullyRevived) {
                                ctx.shadowColor = '#90EE90';
                                ctx.shadowBlur = 10;
                            }
                            
                            // Larger, more visible leaf clusters along the branch
                            for (let i = 0.2; i <= 1; i += 0.25) {
                                const leafX = tree.x + branch.x + Math.cos(branch.angle) * branch.length * i;
                                const leafY = tree.y + branch.y + Math.sin(branch.angle) * branch.length * i;
                                
                                // Draw multiple small leaves in a cluster
                                for (let j = 0; j < 3; j++) {
                                    ctx.beginPath();
                                    const offsetX = (Math.random() - 0.5) * 8;
                                    const offsetY = (Math.random() - 0.5) * 8;
                                    ctx.arc(leafX + offsetX, leafY + offsetY, 3 + Math.random() * 3, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        }
                    }
                    
                    ctx.restore();
                } else {
                    // Regular background trees (same as Level 1)
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(tree.x - 15, tree.y, 30, tree.height);
                    
                    // Tree leaves (different colors based on type)
                    ctx.fillStyle = tree.type === 'tall' ? '#228B22' : '#32CD32';
                    ctx.beginPath();
                    ctx.ellipse(tree.x, tree.y - 20, 60, 80, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw ropes (same as Level 1)
            ctx.fillStyle = '#228B22';
            for (let rope of ropes) {
                ctx.fillRect(rope.x, rope.y, rope.width, rope.height);
                
                // Rope texture
                ctx.fillStyle = '#32CD32';
                for (let i = 0; i < rope.height; i += 15) {
                    ctx.fillRect(rope.x + 2, rope.y + i, rope.width - 4, 3);
                }
                ctx.fillStyle = '#228B22';
            }

            // Draw coins with golden icon
            for (let coin of coins) {
                if (!coin.collected) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width/2, coin.y + coin.height/2, coin.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Coin highlight
                    ctx.fillStyle = '#FFF700';
                    ctx.beginPath();
                    ctx.arc(coin.x + coin.width/2 - 2, coin.y + coin.height/2 - 2, coin.width/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Coin rotation glow
                    const coinGlow = Math.sin(Date.now() * 0.008) * 3;
                    ctx.shadowBlur = 10 + coinGlow;
                    ctx.shadowColor = '#FFD700';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Draw gems with crystal icon
            for (let gem of gems) {
                if (!gem.collected) {
                    ctx.fillStyle = '#9932CC';
                    // Diamond shape
                    ctx.beginPath();
                    ctx.moveTo(gem.x + gem.width/2, gem.y);
                    ctx.lineTo(gem.x + gem.width, gem.y + gem.height/2);
                    ctx.lineTo(gem.x + gem.width/2, gem.y + gem.height);
                    ctx.lineTo(gem.x, gem.y + gem.height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Gem highlight
                    ctx.fillStyle = '#DA70D6';
                    ctx.beginPath();
                    ctx.moveTo(gem.x + gem.width/2, gem.y + 2);
                    ctx.lineTo(gem.x + gem.width - 3, gem.y + gem.height/2);
                    ctx.lineTo(gem.x + gem.width/2, gem.y + gem.height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Gem glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#9932CC';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Draw collectibles (Water Relic)
            for (let collectible of collectibles) {
                if (!collectible.collected) {
                    if (collectible.type === 'water-relic') {
                        // Water Relic with droplet icon
                        const pulse = Math.sin(Date.now() * 0.01) * 3;
                        
                        // Water droplet shape
                        ctx.fillStyle = '#00BFFF';
                        ctx.beginPath();
                        ctx.arc(collectible.x + collectible.width/2, collectible.y + collectible.height - 10, 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Water droplet top
                        ctx.beginPath();
                        ctx.moveTo(collectible.x + collectible.width/2, collectible.y + 5);
                        ctx.quadraticCurveTo(collectible.x + collectible.width/2 - 8, collectible.y + 15, collectible.x + collectible.width/2, collectible.y + collectible.height - 10);
                        ctx.quadraticCurveTo(collectible.x + collectible.width/2 + 8, collectible.y + 15, collectible.x + collectible.width/2, collectible.y + 5);
                        ctx.fill();
                        
                        // Relic glow effect
                        ctx.shadowBlur = 20 + pulse;
                        ctx.shadowColor = '#00BFFF';
                        ctx.fill();
                        
                        // Water relic highlight
                        ctx.fillStyle = '#87CEEB';
                        ctx.beginPath();
                        ctx.arc(collectible.x + collectible.width/2 - 3, collectible.y + collectible.height - 13, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                    } else if (collectible.type === 'spirit-tree') {
                        // Animated Spirit Tree
                        drawAnimatedSpiritTree(collectible.x, collectible.y, collectible.width, collectible.height);
                    }
                }
            }

            // Draw time boosts with clock icons
            for (let boost of timeBoosts) {
                if (!boost.collected) {
                    // Clock face
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(boost.x + boost.width/2, boost.y + boost.height/2, boost.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Clock border
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Clock hands
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(boost.x + boost.width/2, boost.y + boost.height/2);
                    ctx.lineTo(boost.x + boost.width/2, boost.y + 4);
                    ctx.moveTo(boost.x + boost.width/2, boost.y + boost.height/2);
                    ctx.lineTo(boost.x + boost.width - 3, boost.y + boost.height/2);
                    ctx.stroke();
                    
                    // Clock glow
                    const clockGlow = Math.sin(Date.now() * 0.01) * 5;
                    ctx.shadowBlur = 15 + clockGlow;
                    ctx.shadowColor = '#FFD700';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Draw player (exact warrior from Level 1 and Level 3)
            const x = player.x;
            const y = player.y;
            const frame = Date.now() * 0.01;
            
            // Animation calculations
            let bodyOffset = 0;
            let legOffset1 = 0;
            let legOffset2 = 0;
            let armOffset = 0;
            let headBob = 0;
            
            if (Math.abs(player.velocityX) > 0.1) {
                // Running animation
                bodyOffset = Math.sin(frame * 0.5) * 1;
                legOffset1 = Math.sin(frame * 0.8) * 2;
                legOffset2 = Math.sin(frame * 0.8 + Math.PI) * 2;
                armOffset = Math.sin(frame * 0.6) * 1;
                headBob = Math.sin(frame * 0.4) * 0.5;
            }
            
            // Warrior colors (from Level 1/3)
            const baseColor = '#8B4513';
            const armorColor = '#C0C0C0';
            const weaponColor = '#FFD700';
            
            // Legs with running animation
            const leg1X = x + 12;
            const leg2X = x + 22;
            ctx.fillStyle = baseColor;
            ctx.fillRect(leg1X, y + 45 + legOffset1, 6, 8);
            ctx.fillRect(leg2X, y + 45 + legOffset2, 6, 8);
            
            // Boots
            ctx.fillStyle = '#654321';
            ctx.fillRect(leg1X - 1, y + 51 + legOffset1, 8, 3);
            ctx.fillRect(leg2X - 1, y + 51 + legOffset2, 8, 3);
            
            // Main body armor with gradient
            ctx.fillStyle = baseColor;
            ctx.fillRect(x + 8, y + 15 + bodyOffset, 24, 30);
            
            // Armor details with metallic shine
            ctx.fillStyle = armorColor;
            ctx.fillRect(x + 10, y + 17 + bodyOffset, 20, 4);
            ctx.fillRect(x + 12, y + 25 + bodyOffset, 16, 2);
            ctx.fillRect(x + 14, y + 35 + bodyOffset, 12, 2);
            
            // Metallic shine effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(x + 11, y + 18 + bodyOffset, 2, 3);
            ctx.fillRect(x + 13, y + 26 + bodyOffset, 2, 1);
            
            // Arms with enhanced animation
            ctx.fillStyle = baseColor;
            const arm1Y = y + 20 + armOffset;
            const arm2Y = y + 20 - armOffset;
            ctx.fillRect(x + 5, arm1Y, 6, 15);
            ctx.fillRect(x + 29, arm2Y, 6, 15);
            
            // Arm armor
            ctx.fillStyle = armorColor;
            ctx.fillRect(x + 6, arm1Y + 2, 4, 3);
            ctx.fillRect(x + 30, arm2Y + 2, 4, 3);
            
            // Head with expression
            ctx.fillStyle = '#FFE4B5';
            ctx.fillRect(x + 12, y + 5 + headBob, 16, 12);
            
            // Helmet with decorative elements
            ctx.fillStyle = armorColor;
            ctx.fillRect(x + 10, y + 3 + headBob, 20, 8);
            // Helmet decoration
            ctx.fillStyle = weaponColor;
            ctx.fillRect(x + 18, y + 1 + headBob, 4, 3);
            
            // Eyes with direction awareness
            ctx.fillStyle = '#000';
            const eyeY = y + 8 + headBob;
            if (player.facingRight) {
                ctx.fillRect(x + 20, eyeY, 2, 2);
                ctx.fillRect(x + 24, eyeY, 2, 2);
                // Eye highlight
                ctx.fillStyle = '#FFF';
                ctx.fillRect(x + 20, eyeY, 1, 1);
                ctx.fillRect(x + 24, eyeY, 1, 1);
            } else {
                ctx.fillRect(x + 14, eyeY, 2, 2);
                ctx.fillRect(x + 18, eyeY, 2, 2);
                // Eye highlight
                ctx.fillStyle = '#FFF';
                ctx.fillRect(x + 14, eyeY, 1, 1);
                ctx.fillRect(x + 18, eyeY, 1, 1);
            }
            
            // Basic sword weapon
            ctx.fillStyle = weaponColor;
            if (player.facingRight) {
                ctx.fillRect(x + 35, y + 18, 3, 12);
                ctx.fillRect(x + 34, y + 15, 5, 3); // Hilt
            } else {
                ctx.fillRect(x + 2, y + 18, 3, 12);
                ctx.fillRect(x + 1, y + 15, 5, 3); // Hilt
            }

            // Restore context
            ctx.restore();
        }

        // ===============================================
        // EVENT HANDLERS
        // ===============================================
        function handleKeyDown(event) {
            game.keys[event.key] = true;
            event.preventDefault();
        }

        function handleKeyUp(event) {
            game.keys[event.key] = false;
            event.preventDefault();
        }

        // ===============================================
        // MAIN GAME LOOP
        // ===============================================
        function gameLoop() {
            if (!game.gameComplete) {
                updatePlayer();
                updateCamera();
                updateTimer();
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // ===============================================
        // INITIALIZATION
        // ===============================================
        function initGame() {
            loadGameData();
            initializeBothPages(); // Initialize both pages like Level 1
            // Player starts on Page 1, Page 2 is blocked until Water Relic is collected
            
            // Hide duplicate relic displays in hud-left (keep only the ones in hud-right)
            const hudLeftItems = document.querySelectorAll('.hud-left .hud-item');
            hudLeftItems.forEach(item => {
                // Keep only the timer display, hide relic displays
                if (!item.classList.contains('timer-display')) {
                    const hasRelicId = item.querySelector('#forestRelic, #emberRelic, #waterRelic');
                    if (hasRelicId) {
                        item.style.display = 'none';
                    }
                }
            });
            
            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Create ambient water particles
            setInterval(() => {
                const particle = document.createElement('div');
                particle.className = 'water-particle';
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.animationDelay = Math.random() * 2 + 's';
                document.body.appendChild(particle);
                
                setTimeout(() => particle.remove(), 3000);
            }, 200);
            
            showMessage("🌳 Final Challenge: Navigate the Water Castle and collect the Water Relic to revive the Spirit Tree!");
            
            // Start game loop
            gameLoop();
        }

        // Start the game
        initGame();
    </script>
</body>
</html>